I"9™<p>I just realized that I‚Äôve been using Vim for just about a year now (here‚Äôs <a href="http://sts10.github.io/2015/02/15/vim-update.html">one of my early posts on starting to make the switch</a>), so I figured it‚Äôd be a good time to go over some of favorite parts of <a href="https://github.com/sts10/terminal_and_vim_settings/blob/master/vimrc">my vimrc</a>. I‚Äôm certainly no Vim expert, but if nothing else than recording my ‚Äúprogress,‚Äù here‚Äôs a bit about how I use Vim at this point.</p>

<p>I‚Äôve already written about <a href="http://sts10.github.io/2015/08/02/markdwon-hyperlink-remap-for-vim.html">a Markdown hyperlink remap</a> that still works really well and <a href="http://sts10.github.io/2015/09/13/ditching-nerdtree-and-using-vims-default-file-explorer.html">how I ditched NERDTree in favor of netrw</a>. But there‚Äôs plenty of more, smaller tricks I‚Äôve picked up since then.</p>

<!-- more -->

<p><strong>Note from May 2017</strong>: My vimrc has changed a bit since I wrote this post, which I wrote in February of 2016. But rather than update it with each new plugin and mapping, I‚Äôm going to leave this post as is, as the setup is still pretty solid. You can see <a href="https://github.com/sts10/terminal_and_vim_settings/blob/master/vimrc">my relatively up-to-date vimrc here</a>.</p>

<h2 id="vim-vs-macvim-vs-neovim">Vim vs. MacVim vs. Neovim</h2>

<p>Basically I split my usage between <a href="https://github.com/neovim/neovim">Neovim</a> and <a href="https://github.com/macvim-dev/macvim/releases/">MacVim</a>. Sometimes I want to stay in the terminal (in which case I fire up Neovim), and other times I want a separate GUI. I‚Äôll also admit that part of the reason I do this is because the iTerm2 + Neovim combo isn‚Äôt super stable at this point, as I‚Äôm running a beta version of iTerm2 <a href="http://sts10.github.io/2015/10/24/true-hex-colors-with-neovim-and-iterm2.html">in order to get better/more colors for Neovim</a>.</p>

<p>One way to make using both easier is to use your existing configuration by making these two symlinks:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To use your existing Vim configuration:
    ln -s ~/.vim ~/.config/nvim
    ln -s ~/.vimrc ~/.config/nvim/init.vim
See ':help nvim' for more information on Neovim.
</code></pre></div></div>

<p>Or you can maintain a separate Vim config file for Neovim by simply putting your config code into <code class="language-plaintext highlighter-rouge">~/.config/nvim/init.vim</code>. (Just to be clear, most settings work in both regualr Vim and Neovim.) If you choose this route, obviously your config file is no longer called <code class="language-plaintext highlighter-rouge">vimrc</code> but rather <code class="language-plaintext highlighter-rouge">init.vim</code>. Just note that, throughout this post I‚Äôll likely keep referring to my Vim config file as ‚Äúmy vimrc‚Äù.</p>

<p>Neovim + iTerm2 is a pretty great combo, but for somethings I like using a GUI (MacVim). (I haven‚Äôt found a good Neovim GUI yet, though there are some other there, including <a href="https://github.com/rogual/neovim-dot-app">Neovim dot app</a>.)</p>

<h2 id="my-plugin-manager">My Plugin Manager</h2>

<p>To manage my ever-changing list of vim plugins I use <a href="https://github.com/junegunn/vim-plug">vim-plug</a>, which works really well.</p>

<p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt="vim-plug in action" /></p>

<p>In fact the first few lines of my vimrc automatically installs vim-plug if it‚Äôs not detected then installs all the listed plugins, a trick I picked up from vim-plug‚Äôs <a href="https://github.com/junegunn/vim-plug/wiki/faq">FAQ</a>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" vim-plug (https://github.com/junegunn/vim-plug) settings 
" Automatically install vim-plug and run PlugInstall if vim-plug not found
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | source $MYVIMRC
endif
</code></pre></div></div>

<p>I can then list my desired plugins as Github addresses:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">call</span> plug#begin<span class="p">(</span><span class="s1">'~/.vim/plugged'</span><span class="p">)</span>
Plug <span class="s1">'ctrlpvim/ctrlp.vim'</span>
Plug <span class="s1">'terryma/vim-smooth-scroll'</span>
Plug <span class="s1">'matze/vim-move'</span>
Plug <span class="s1">'tpope/vim-commentary'</span>
Plug <span class="s1">'sickill/vim-pasta'</span>
Plug <span class="s1">'justinmk/vim-sneak'</span>
Plug <span class="s1">'tpope/vim-vinegar'</span>
Plug <span class="s1">'ervandew/supertab'</span>
Plug <span class="s1">'vim-ruby/vim-ruby'</span>
Plug <span class="s1">'tpope/vim-rails'</span>
Plug <span class="s1">'tpope/vim-unimpaired'</span>
Plug <span class="s1">'tpope/vim-markdown'</span>
Plug <span class="s1">'sts10/vim-pink-moon'</span>
Plug <span class="s1">'sts10/vim-mustard'</span>
Plug <span class="s1">'junegunn/seoul256.vim'</span>
Plug <span class="s1">'altercation/vim-colors-solarized'</span>
Plug <span class="s1">'tpope/vim-surround'</span>
Plug <span class="s1">'tpope/vim-repeat'</span>
Plug <span class="s1">'bronson/vim-visual-star-search'</span>
Plug <span class="s1">'terryma/vim-multiple-cursors'</span>
Plug <span class="s1">'junegunn/goyo.vim'</span>
Plug <span class="s1">'tmhedberg/matchit'</span>
Plug <span class="s1">'kana/vim-textobj-user'</span>
Plug <span class="s1">'lucapette/vim-textobj-underscore'</span> <span class="p">|</span> Plug <span class="s1">'kana/vim-textobj-user'</span>
Plug <span class="s1">'jceb/vim-textobj-uri'</span>             <span class="p">|</span> Plug <span class="s1">'kana/vim-textobj-user'</span>
Plug <span class="s1">'kana/vim-textobj-indent'</span>          <span class="p">|</span> Plug <span class="s1">'kana/vim-textobj-user'</span>
Plug <span class="s1">'kana/vim-textobj-line'</span>            <span class="p">|</span> Plug <span class="s1">'kana/vim-textobj-user'</span>
Plug <span class="s1">'wellle/targets.vim'</span>
Plug <span class="s1">'sts10/vim-zipper'</span>
Plug <span class="s1">'tpope/vim-fugitive'</span>

<span class="c">" All of your Plugins must be added before the following line</span>
<span class="k">call</span> plug#end<span class="p">()</span>
</code></pre></div></div>

<p>And I‚Äôm good to go. I can run <code class="language-plaintext highlighter-rouge">:PlugUpdate</code> to get the latest versions of all the plugins, or <code class="language-plaintext highlighter-rouge">:PlugUpgrade</code> to upgrade vim-plug itself. For me vim-plug offers three advantages over <a href="https://github.com/VundleVim/Vundle.vim">Vundle</a>: (1) The automatic install script (shown above) is nice for portability, (2) When using Neovim, vim-plug updates the plugins asynchronously, and (3) you don‚Äôt have to turn off file type detection (<code class="language-plaintext highlighter-rouge">filetype off</code>) in your vimrc when you list your plugins with vim-plug, <a href="https://github.com/VundleVim/Vundle.vim#quick-start">as you do with Vundle</a>.</p>

<h2 id="quick-note-on-remappings">Quick Note on Remappings</h2>

<p><a href="http://learnvimscriptthehardway.stevelosh.com/chapters/05.html">This blog post</a> recommends always using <code class="language-plaintext highlighter-rouge">nnoremap</code> over <code class="language-plaintext highlighter-rouge">nmap</code> (and the <code class="language-plaintext highlighter-rouge">inoremap</code> and <code class="language-plaintext highlighter-rouge">vnoremap</code> equivalents) to avoid recursion. So I‚Äôve strived to do that in all situations where both options work. If <code class="language-plaintext highlighter-rouge">nnoremap</code> doesn‚Äôt work but <code class="language-plaintext highlighter-rouge">nmap</code> does (which is the case some of the time), I just use <code class="language-plaintext highlighter-rouge">nmap</code>.</p>

<h2 id="favorite-plugins-and-my-configurations">Favorite Plugins and My Configurations</h2>

<p>While, as you can see, I‚Äôve got a more than 20 plugins listed above, there‚Äôs only a few that are super important to my workflow. Among these I would include <a href="https://github.com/tpope/vim-surround">vim-surround</a>, <a href="https://github.com/justinmk/vim-sneak">vim-sneak</a>, <a href="https://github.com/tpope/vim-commentary">vim-commentary</a>, <a href="https://github.com/matze/vim-move">vim-move</a>, and maybe <a href="https://github.com/terryma/vim-smooth-scroll">vim-smooth-scroll</a>.</p>

<p>I map sneak to Tab and Shift + Tab as follows (works in MacVim and Neovim + iTerm2):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" https://github.com/justinmk/vim-sneak
" Map Sneak_s using nmap-- not nnoremap. That seems to cause problems
nmap &lt;Tab&gt; &lt;Plug&gt;Sneak_s
nmap &lt;S-Tab&gt; &lt;Plug&gt;Sneak_S
vmap &lt;Tab&gt; &lt;Plug&gt;Sneak_s
vmap &lt;S-Tab&gt; &lt;Plug&gt;Sneak_S
</code></pre></div></div>

<p>(Update from 2017: <a href="https://www.reddit.com/r/vim/comments/6912rf/best_of_my_vimrc/dh33shb/">A Reddit user points out</a> that by using these mappings I‚Äôm giving up Vim‚Äôs default mapping/functionality, which I must be true. That‚Äôs a choice I made and I like it.)</p>

<p>And I set vim-move to <code class="language-plaintext highlighter-rouge">&lt;c-j&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;c-k&gt;</code> with <code class="language-plaintext highlighter-rouge">let g:move_key_modifier = 'C'</code>. Previously, I had used <a href="https://github.com/tpope/vim-unimpaired">vim-unimpaired</a>‚Äôs <code class="language-plaintext highlighter-rouge">[e</code> and <code class="language-plaintext highlighter-rouge">]e</code> mappings to move lines up and down (aka ‚Äúbubbling‚Äù text), but I eventually switched to vim-move because vim-move auto-indents your code as you move it, which isn‚Äôt without a speed cost sometimes, but is really nice for me visually. Plus vim-unimpaired has a bunch of other default mappings besides <code class="language-plaintext highlighter-rouge">[e</code> and <code class="language-plaintext highlighter-rouge">]e</code> that I didn‚Äôt use (but that you may like!).</p>

<p><img src="https://camo.githubusercontent.com/c06acab07e6bf0bb27086c9694fe2f456101d21c/687474703a2f2f692e696d6775722e636f6d2f524d76384b734a2e676966" alt="vim-move in action" /></p>

<p>For more of my ~opinions~ plugins, I previously wrote about what I see as the <a href="http://sts10.github.io/2015/09/12/two-types-of-vim-plugins.html">two types of vim plugins</a>.</p>

<h2 id="colorscheme">Colorscheme</h2>

<p><img src="https://github.com/sts10/vim-pink-moon/raw/master/img/pink-moon-frontend.png" alt="Pink Moon colorscheme screenshot from GitHub repo" /></p>

<p>For a long time I used a colorscheme called <a href="https://github.com/sts10/vim-mustard">Mustard</a>, which I adapted from a Sublime Text 2 colorscheme also called Mustard (located <a href="https://github.com/panrafal/mustard-theme">here</a>). However I‚Äôve since switched to <a href="https://github.com/sts10/vim-pink-moon">Pink Moon</a>, a colorscheme I wrote for myself basically from scratch.</p>

<p>Thanks to the file structure of both Mustard and Pink Moon, you can have vim-plug install and manage them by including <code class="language-plaintext highlighter-rouge">Plug 'sts10/vim-pink-moon'</code> and/or <code class="language-plaintext highlighter-rouge">Plug 'sts10/vim-mustard'</code> in your Vim config file (likely your vimrc) (they should work with other plugin managers too). Then be sure to have <code class="language-plaintext highlighter-rouge">colorscheme pink-moon</code> or <code class="language-plaintext highlighter-rouge">colorscheme mustard</code> in your Vim config file. With Mustard, you‚Äôll have to also have <code class="language-plaintext highlighter-rouge">set background=dark</code> in your Vim config file.</p>

<p>Of course there are tons of other Vim colorschemes a few Google searches away!</p>

<h2 id="line-numbers">Line Numbers</h2>

<p>I love my line numbers settings. I have relative number lines on every line except the one I‚Äôm currently on, which I have display the absolute number line rather than just <code class="language-plaintext highlighter-rouge">0</code>. Here‚Äôs how I get that set up:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Display relative line numbers
set relativenumber
" display the absolute line number at the line you're on
set number

" Keep the line number gutter narrow so three digits is cozy. 
set numberwidth=2
</code></pre></div></div>

<p>This way, I can easily go up or down to specific line with <code class="language-plaintext highlighter-rouge">count + j</code> or <code class="language-plaintext highlighter-rouge">k</code>, but if Ruby tells me I have an error on line 76 I can just run <code class="language-plaintext highlighter-rouge">:76</code> and the absolute line number will confirm that I landed on line 76.</p>

<h2 id="page-navigation">Page Navigation</h2>

<p>I have two nice sets of mappings that make file navigation a little easier for me.</p>

<p>This first one is a bit tricky to explain. First, know that I linewrap on certain filetypes with the following autocmds:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" By default don't wrap lines
set nowrap 

" But do wrap on these types of files...
autocmd FileType markdown setlocal wrap
autocmd FileType html setlocal wrap
</code></pre></div></div>

<p>But then I ran into the problem of <code class="language-plaintext highlighter-rouge">j</code> and <code class="language-plaintext highlighter-rouge">k</code> skipping over wrapped lines. I initially fixed this by simply remapping <code class="language-plaintext highlighter-rouge">j</code> as <code class="language-plaintext highlighter-rouge">gj</code> and <code class="language-plaintext highlighter-rouge">k</code> as <code class="language-plaintext highlighter-rouge">gk</code>. However, this gets screwy when you use a count with <code class="language-plaintext highlighter-rouge">j</code> or <code class="language-plaintext highlighter-rouge">k</code>. If you‚Äôre navigating by relative numbers with a count, you want <code class="language-plaintext highlighter-rouge">j</code> and <code class="language-plaintext highlighter-rouge">k</code>, when using a count, treating wrapped lines as one line rather than multiple lines.</p>

<p>Thanks to <a href="https://www.reddit.com/r/vim/comments/2k4cbr/problem_with_gj_and_gk/cliuz1o">this Reddit comment</a>, I found the perfect solution to this problem:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" j and k don't skip over wrapped lines in following FileTypes, unless given a count (helpful since I display relative line numbers in these file types)
autocmd FileType html nnoremap &lt;expr&gt; j v:count ? 'j' : 'gj'
autocmd FileType html nnoremap &lt;expr&gt; k v:count ? 'k' : 'gk'
autocmd FileType markdown nnoremap &lt;expr&gt; j v:count ? 'j' : 'gj'
autocmd FileType markdown nnoremap &lt;expr&gt; k v:count ? 'k' : 'gk'
</code></pre></div></div>

<p>I later simplified these mappings and added visual mode support (plus using it in <code class="language-plaintext highlighter-rouge">text</code> files) like this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autocmd FileType html,markdown,text nnoremap &lt;expr&gt; j v:count ? 'j' : 'gj'
autocmd FileType html,markdown,text nnoremap &lt;expr&gt; k v:count ? 'k' : 'gk'

autocmd FileType html,markdown,text vnoremap &lt;expr&gt; j v:count ? 'j' : 'gj'
autocmd FileType html,markdown,text vnoremap &lt;expr&gt; k v:count ? 'k' : 'gk'
</code></pre></div></div>

<p>My next trick is just to switch <code class="language-plaintext highlighter-rouge">&lt;c-e&gt;</code> (by default scrolls up one line without moving cursor) and <code class="language-plaintext highlighter-rouge">&lt;c-u&gt;</code> (by default scrolls up half a page). This conveniently puts scroll half page up (now <code class="language-plaintext highlighter-rouge">&lt;c-e&gt;</code>) right above the default keymap for scroll half page down, which is <code class="language-plaintext highlighter-rouge">&lt;c-d&gt;</code>.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Easier page navigation
nnoremap &lt;C-e&gt; &lt;C-u&gt;
nnoremap &lt;C-u&gt; &lt;C-e&gt;
</code></pre></div></div>

<p>However I found that scrolling by this much instantly was a bit jarring. It took me a while to figure out why until, I realized that in Sublime Text I usually scrolled with my mouse‚Äôs scroll wheel (ugh), which was a bit more gradual. After some Googling I found <a href="https://github.com/terryma/vim-smooth-scroll">vim-smooth-scroll</a>, which slows down any scroll/movement command that you specify.</p>

<p>Here‚Äôs how I configure the plugin:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>noremap &lt;silent&gt; &lt;c-e&gt; :call smooth_scroll#up(&amp;scroll, 30, 2)&lt;CR&gt;
noremap &lt;silent&gt; &lt;c-d&gt; :call smooth_scroll#down(&amp;scroll, 30, 2)&lt;CR&gt;
noremap &lt;silent&gt; &lt;c-b&gt; :call smooth_scroll#up(&amp;scroll*2, 30, 4)&lt;CR&gt;
noremap &lt;silent&gt; &lt;c-f&gt; :call smooth_scroll#down(&amp;scroll*2, 30, 4)&lt;CR&gt;
</code></pre></div></div>

<p>I also make use of Vim‚Äôs default normal commands <code class="language-plaintext highlighter-rouge">{</code> and <code class="language-plaintext highlighter-rouge">}</code> to navigate by ‚Äúparagraph‚Äù (blank lines).</p>

<h2 id="statusline">Statusline</h2>

<p>Just recently I decided to write my own custom statusline. Previously I had tried a plugin solution to a statusline, like <a href="https://github.com/vim-airline/vim-airline">airline</a> or <a href="https://github.com/itchyny/lightline.vim">lightline</a>. I forget which one I actually tried, but I couldn‚Äôt get it to work for me.</p>

<p>Later I found a few blog posts (<a href="http://got-ravings.blogspot.co.at/2008/08/vim-pr0n-making-statuslines-that-own.html">this one in particular</a>) that helped me write my own, which is pretty similar to the one that blog post says Tim Pope was using.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set statusline=%f
set statusline+=\ %h%w%m%r
set statusline+=%=
set statusline+=%-16(%{exists('g:loaded_fugitive')?fugitive#statusline():''}\%)
set statusline+=\ %P/%L
set statusline+=\ 
</code></pre></div></div>

<p>It gives basics like filename, percentage through the file, total number of lines, necessary flags, etc. The only fancy part is the <code class="language-plaintext highlighter-rouge">fugitive#statusline</code>, which gives me the current Git branch, if you‚Äôre in a git directory AND you have <a href="https://github.com/tpope/vim-fugitive">Fugitive</a> installed. At this point this is the only reason I have Fugitive installed, though I‚Äôm sure others find its other features helpful (from the README: ‚ÄúI‚Äôm not going to lie to you; fugitive.vim may very well be the best Git wrapper of all time.‚Äù).</p>

<h2 id="setting-default-filetype">Setting Default FileType</h2>

<p>I write Markdown pretty frequently, so I set Vim to set new files to Markdown syntax with the following line:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" if no filetype specified, set ft=markdown (alternative would be text)
autocmd BufEnter * if &amp;filetype == "" | setlocal ft=markdown | endif
</code></pre></div></div>

<h2 id="markdown-tricks">Markdown Tricks</h2>

<p>For Markdown, I use <a href="https://github.com/tpope/vim-markdown">tpope‚Äôs vim-markdown</a> mostly for improved syntax highlighting. I also spell out some languages for it to highlight in between code fences with:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let g:markdown_fenced_languages = ['html', 'css', 'javascript', 'ruby', 'python', 'bash=sh', 'yaml', 'json']
</code></pre></div></div>

<p>As mentioned above, I also wrote a handy little mapping for quickly creating links in Markdown, assuming the URL is in your system clipboard:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" In markdown files, Control + a surrounds highlighted text with square
" brackets, then dumps system clipboard contents into parenthesis
autocmd FileType markdown vnoremap &lt;c-a&gt; &lt;Esc&gt;`&lt;i[&lt;Esc&gt;`&gt;la](&lt;Esc&gt;"*]pa)&lt;Esc&gt;
</code></pre></div></div>

<p>Read more about my process coming to that mapping in <a href="https://sts10.github.io/2015/08/02/markdwon-hyperlink-remap-for-vim.html">this slightly-too-long blog post</a> if you like.</p>

<h2 id="backup-swap-and-undo">Backup, Swap, and Undo</h2>

<p>For backup, swap, and undo files‚Äì which I found frequently got mixed into Git repos no matter what I did with my gitignores‚Äì I found this solution, which basically shoves all those files into three directories, rather than individual local project directories. We also have to <a href="http://stackoverflow.com/a/22676189/3160994">setup Vim‚Äôs persistent undo</a>.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Save temporary/backup files not in the local directory, but in your ~/.vim
" directory, to keep them out of git repos. 
" But first mkdir backup, swap, and undo first to make this work
call system('mkdir ~/.vim')
call system('mkdir ~/.vim/backup')
call system('mkdir ~/.vim/swap')
set backupdir=~/.vim/backup//
set directory=~/.vim/swap//

" Keep undo history across sessions by storing it in a file
if has('persistent_undo')
    call system('mkdir ~/.vim/undo')
    set undodir=~/.vim/undo//
    set undofile
    set undolevels=1000
    set undoreload=10000
endif
</code></pre></div></div>

<p>This code even creates the directories for you (at least in macOS, using <code class="language-plaintext highlighter-rouge">mkdir</code>) if they haven‚Äôt already been created, so portability is maintained. The commands do not overwrite the directory if it already exists.</p>

<h2 id="search-settings">Search Settings</h2>

<p>I like my search settings: ignore case unless you uppercase a letter, search as you type, and don‚Äôt highlight all matches.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" set search case to a good configuration http://vim.wikia.com/wiki/Searching 
set ignorecase
set smartcase

" search characters as they're entered
set incsearch
" don't highlight all search matches
set nohlsearch
</code></pre></div></div>

<h2 id="text-objects">Text Objects</h2>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plug 'kana/vim-textobj-user'
Plug 'lucapette/vim-textobj-underscore' | Plug 'kana/vim-textobj-user'
Plug 'jceb/vim-textobj-uri'             | Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-indent'          | Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-line'            | Plug 'kana/vim-textobj-user'
</code></pre></div></div>

<p>I‚Äôve recently added four extra text objects, using <a href="https://github.com/kana/vim-textobj-user">kana‚Äôs vim-textobj-user</a> plugin. With <code class="language-plaintext highlighter-rouge">underscore</code>, <code class="language-plaintext highlighter-rouge">uri</code>, <code class="language-plaintext highlighter-rouge">indent</code>, and <code class="language-plaintext highlighter-rouge">line</code>, I get more text objects in Vim. So for example <code class="language-plaintext highlighter-rouge">viu</code> visually-selects the URI you‚Äôre on, and <code class="language-plaintext highlighter-rouge">yil</code> yanks the inner ‚Äúline‚Äù. There‚Äôs a ton more information in <a href="https://github.com/kana/vim-textobj-user/wiki">the wiki</a>.</p>

<p>At one point I thought that I needed the <code class="language-plaintext highlighter-rouge">|</code> there because <a href="https://github.com/junegunn/vim-plug">vim-plug</a> syntax allowed it to denote <a href="https://github.com/junegunn/vim-plug#example">a plugin dependency</a>. (My understanding is that putting the ‚Äútextobj-user‚Äù first in my vimrc is not sufficient due to vim-plug + Neovim‚Äôs asynchronous plugin installing and updating.) I indented it like so to make it look nice.</p>

<p>But <a href="https://www.reddit.com/r/vim/comments/6912rf/best_of_my_vimrc/dh2ywoj/">this Reddit user points out</a> that ‚Äú<code class="language-plaintext highlighter-rouge">|</code> is just a way to simulate line breaks in vim script. Vim-plug doesn‚Äôt have support for ‚Äúdependencies‚Äù, it‚Äôs just a way of writing it so you can keep track of it.‚Äù</p>

<p>According to that Reddit comment, I think I could just have:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plug 'kana/vim-textobj-user'
Plug 'lucapette/vim-textobj-underscore' 
Plug 'jceb/vim-textobj-uri'            
Plug 'kana/vim-textobj-indent'        
Plug 'kana/vim-textobj-line'         
</code></pre></div></div>

<p>Also, with <code class="language-plaintext highlighter-rouge">textobj-uri</code>, I can remap <code class="language-plaintext highlighter-rouge">gx</code> to work better and with more type of URLs (see <a href="https://sts10.github.io/2016/02/16/one-solution-to-a-problem-with-vims-gx-command.html">this blog post for more</a>):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" map gx and go to visually select a URI and then open it in default browser
" see: http://sts10.github.io/2016/02/16/one-solution-to-a-problem-with-vims-gx-command.html
nmap gx mxviugx&lt;Esc&gt;`x
</code></pre></div></div>

<p>I also added <a href="https://github.com/wellle/targets.vim">targets.vim</a> to get even more text objects. Basically my reasoning is the more text objects the better for when I‚Äôm creating a complex macro on the fly or need to do something complex within one command so that it is repeatable with the dot command (see <a href="https://github.com/tpope/vim-repeat">vim-repeat</a>, a plugin for making the dot command work with some plugins).</p>

<h2 id="folding-with-vim-zipper-my-first-vim-plugin">Folding with vim-zipper, My First Vim Plugin</h2>

<p>I learned about Vim‚Äôs folding functionality pretty early on (see <code class="language-plaintext highlighter-rouge">:help folding</code>) but I never really used it. In fact I still can‚Äôt quite get <code class="language-plaintext highlighter-rouge">set foldmethod=syntax</code> to find the folds that I think it should.</p>

<p>So for a while I just <code class="language-plaintext highlighter-rouge">set foldmethod=marker</code> and really only used it in my vimrc.</p>

<p>Later I realized the power of <code class="language-plaintext highlighter-rouge">set foldmethod=indent</code>. I particularly liked that it was pretty intuitive to see how it would fold code (by indent!) but it also wouldn‚Äôt slow Vim down like the <code class="language-plaintext highlighter-rouge">syntax</code> method could.</p>

<p>However I wanted to make opening folds easier so I eventually made my first Vim plugin called <a href="https://github.com/sts10/vim-zipper">vim-zipper</a>. You can read about it <a href="https://github.com/sts10/vim-zipper">on GitHub</a> or in <a href="https://sts10.github.io/2016/03/20/vim-zipper-my-first-vim-plugin.html">another blog post</a>.</p>

<p><img src="https://raw.githubusercontent.com/sts10/vim-zipper/master/vim-zipper-gif.gif" alt="vim-zipper in action" /></p>

<h2 id="system-clipboard">System Clipboard</h2>

<p>I use my leader (mapped to space) to interact with the system clipboard. I‚Äôm not 100% sure if this is true even on all Unix systems, but when I use Neovim in iTerm2 or MacVim, <code class="language-plaintext highlighter-rouge">*</code> is the register of the system clipboard. I frequently interact with the system clipboard from Vim, so I set up these key mappings to make that easier:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" use leader to interact with the system clipboard
nnoremap &lt;Leader&gt;p "*]p
nnoremap &lt;Leader&gt;P "*]P

nnoremap &lt;Leader&gt;y :y*&lt;cr&gt;
nnoremap &lt;Leader&gt;c ^"*c$
nnoremap &lt;Leader&gt;d ^"*d$

vnoremap &lt;Leader&gt;y "*y
vnoremap &lt;Leader&gt;c "*c
vnoremap &lt;Leader&gt;d "*d
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">]</code> in there automatically auto-indents the pasted text for me, which has worked well in both MacVim and Neovim but not <em>every time</em>. I don‚Äôt think I have any other settings pertaining to the system clipboard at this point.</p>

<h2 id="deleting-text-without-overwriting-any-registers">Deleting Text Without Overwriting Any Registers</h2>

<p>I don‚Äôt love how easy it is to overwrite the contents of your default registry (i.e. when you delete something with <code class="language-plaintext highlighter-rouge">d</code> with the desire to paste it somewhere else, but in the meantime you use <code class="language-plaintext highlighter-rouge">d</code> again trying to actually delete something, but now that‚Äôs overwritten the default registry). To solve this I did my best to make <code class="language-plaintext highlighter-rouge">X</code> (shift + <code class="language-plaintext highlighter-rouge">x</code>) a new operator that deletes things to the ‚Äúblack hole registry,‚Äù <code class="language-plaintext highlighter-rouge">_</code>, which doesn‚Äôt effect the default registry.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap X "_d
nmap XX "_dd
vmap X "_d
vmap x "_d
</code></pre></div></div>

<p>Similarly I make <code class="language-plaintext highlighter-rouge">x</code> in normal mode go to the black hole registry as well:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" have x (removes single character) not go into the default registry
nnoremap x "_x
</code></pre></div></div>

<h2 id="make-visual-mode-a-little-more-powerful">Make Visual Mode a Little More Powerful</h2>

<p>Again in <a href="https://www.reddit.com/r/vim/comments/3y2mgt/do_you_have_any_minor_customizationsmappings_that/cya0x04">a Reddit comment</a> I picked up this one-liner that makes the powerful dot command work on visually-selected lines:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Make the dot command work as expected in visual mode (via
" https://www.reddit.com/r/vim/comments/3y2mgt/do_you_have_any_minor_customizationsmappings_that/cya0x04)
vnoremap . :norm.&lt;CR&gt;
</code></pre></div></div>

<p>Note I‚Äôve also got the <a href="https://github.com/tpope/vim-repeat">vim-repeat</a> plugin to help make the dot command work a little better with other plugins.</p>

<p>Then, in <a href="https://medium.com/@schtoeffel/you-don-t-need-more-than-one-cursor-in-vim-2c44117d51db#.65mg9br0l">a Medium post</a> linked to from a <a href="http://reddit.com/r/vim">r/vim subreddit</a> post that I have since lost track of, I just recently picked up this function that makes macros work over visually-selected lines.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Allows you to visually select a section and then hit @ to run a macro on all lines
" https://medium.com/@schtoeffel/you-don-t-need-more-than-one-cursor-in-vim-2c44117d51db#.3dcn9prw6
xnoremap @ :&lt;C-u&gt;call ExecuteMacroOverVisualRange()&lt;CR&gt;

function! ExecuteMacroOverVisualRange()
  echo "@".getcmdline()
  execute ":'&lt;,'&gt;normal @".nr2char(getchar())
endfunction
</code></pre></div></div>

<p>Both of these have come in handy often. Highly recommended, as they don‚Äôt seem to require new learning or get in the way of any other functionality.</p>

<h2 id="unminifying-javascript">UnMinifying Javascript</h2>

<p>My latest addition to my vimrc is this function and two keymaps for minifying and unminifying Javascript, which I do pretty frequently at work. I picked the function up from <a href="https://gist.github.com/timtyrrell/0640d02bd08cd54f739a">this gist</a>.</p>

<p>I did edit it a bit: (1) I added the <code class="language-plaintext highlighter-rouge">e</code> after the <code class="language-plaintext highlighter-rouge">g</code>s so that it never throws an error if it doesn‚Äôt find a match, (2) removed lines 5 and 8 from the gist‚Äì removing line 5 was a personal preference and I‚Äôm not sure what line 8 does, and (3) I attempted to use a mark <code class="language-plaintext highlighter-rouge">j</code> to save my place, but that doesn‚Äôt seem to work as I wanted it to.</p>

<p>I also added a mapping to join the whole file‚Äì effectively a ‚Äúminify‚Äù command‚Äì so I could easily go back and forth. Works well so far!</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Simple re-format for minified Javascript
function! UnMinify()
    normal mj
    %s/{\ze[^\r\n]/{\r/ge
    %s/};\?\ze[^\r\n]/\0\r/ge
    %s/;\ze[^\r\n]/;\r/ge
    normal ggVG=`j
endfunction

autocmd FileType javascript nnoremap &lt;Leader&gt;j :call UnMinify()&lt;CR&gt;
autocmd FileType javascript nnoremap &lt;Leader&gt;k mjggvGJ&lt;Esc&gt;`j
</code></pre></div></div>

<h2 id="other-random-tips">Other Random Tips</h2>

<p>Here‚Äôs another remapping of Vim‚Äôs default behavior that I consider pretty essential when indenting or un-indenting in visual mode.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>" Have the indent commands re-highlight the last visual selection to make
" multiple indentations easier
vnoremap &gt; &gt;gv
vnoremap &lt; &lt;gv
</code></pre></div></div>

<p>Though I have since removed these lines from my vimrc. The reason being that if I want to indent something multiple times it‚Äôs slightly faster (and more ‚ÄúVim-like in my mind) to use the dot command.</p>

<p>Forgoing the above remappings and using the dot command is faster since if you only want to indent something once (a relatively common case) using visual mode, you want to be dropped into normal mode so you can move on to other tasks that much quicker. You don‚Äôt need to exit visual mode. But it you want to indent the text you just indented, or undo your last indentation move, you can use the dot command or undo (<code class="language-plaintext highlighter-rouge">u</code>) respectively. Both are one keystroke, so no loss there.</p>

<h2 id="default-parts-of-vim-that-i-use-frequently">Default Parts of Vim That I Use Frequently</h2>

<h3 id="exiting-insert-mode">Exiting Insert Mode</h3>

<p>In my early days I had remapped <code class="language-plaintext highlighter-rouge">&lt;Esc&gt;</code> to <code class="language-plaintext highlighter-rouge">ii</code> (<code class="language-plaintext highlighter-rouge">imap ii &lt;Esc&gt;</code>), since escape was so far away, but now I just use <code class="language-plaintext highlighter-rouge">&lt;C-[&gt;</code>, which by default does almost the exactly same thing as <code class="language-plaintext highlighter-rouge">&lt;Esc&gt;</code>.</p>

<h3 id="file-management">File Management</h3>

<p>I‚Äôve tried to find solutions for a couple of problems but have learned to just use Vim‚Äôs defaults. One example would be file-management: I used to use NERDTree, but <a href="http://sts10.github.io/2015/09/13/ditching-nerdtree-and-using-vims-default-file-explorer.html">now just use Vim‚Äôs built-in file explorer</a>, netrw, combined with Tim Pope‚Äôs <a href="https://github.com/tpope/vim-vinegar">vim-vinegar</a>. I do have <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a> (a fuzzy finder) installed, and I even tried <a href="http://sts10.github.io/2016/01/09/vim-line-complete-with-fzf.html">fzf</a>,but I find that I use netrw more frequently. Though granted I have yet to do a lot of work in a project that has many files, like a Rails project would have, which may necessitate a fuzzy finder.</p>

<h3 id="closing-syntax">Closing Syntax</h3>

<p>After using Vim for a while I started to miss how Sublime Text would automatically close brackets and parentheses for you. In Sublime, be default, if you type <code class="language-plaintext highlighter-rouge">def test(</code> it gives you the closing parenthesis and keeps your cursor between them: <code class="language-plaintext highlighter-rouge">def test(|)</code>. Then, most importantly, if you type your argument and type the closing parenthesis, you just ‚Äútype over‚Äù the closing parenthesis that Sublime added for you. It‚Äôs a nice, out-of-the-way implementation that I have been hoping to find in a vim plugin but haven‚Äôt yet (<a href="https://twitter.com/sts10">tweet at me if you have ideas</a>).</p>

<p>I‚Äôve tried a few plugins for auto-closing so far: <a href="https://github.com/Townk/vim-autoclose">vim-autoclose</a> and <a href="https://github.com/rstacruz/vim-closer">vim-closer</a>, as well as <a href="https://github.com/tpope/vim-endwise">vim-endwise</a>, but these days I don‚Äôt use anything and have resigned to just closing my parentheses and brackets and Ruby methods myself by hand. (Update: A Twitter user whose account is private DM‚Äôd me pointing to <a href="https://github.com/Raimondi/delimitMate">delimitMate</a> as an alternative. Separately, <a href="https://twitter.com/VimLinks/status/780693728545693696">@VimLinks</a> has tweeted about <a href="https://github.com/cohama/lexima.vim">lexima.vim</a>, which is another option. I‚Äôve yet to give either a try‚Äì mostly because I‚Äôve grown so used to closing brackets and parentheses manually, but you might find one of them to be the best option for you.)</p>

<h3 id="spellcheck">Spellcheck</h3>

<p>I use <code class="language-plaintext highlighter-rouge">]s</code> and <code class="language-plaintext highlighter-rouge">[s</code> to navigate to the next misspelled word. Once on a misspelled word, just hit <code class="language-plaintext highlighter-rouge">z=</code> to get some suggestions. To ‚Äúteach‚Äù Vim the word under the cursor, use <code class="language-plaintext highlighter-rouge">zg</code>. Looks like <code class="language-plaintext highlighter-rouge">zug</code> undoes the adding to your learned-words list. See <code class="language-plaintext highlighter-rouge">:help spell</code> for more.</p>

<h3 id="find-and-replace">Find and replace</h3>

<p>While I have <code class="language-plaintext highlighter-rouge">multiple-cursors</code> installed, I rarely use it (I just had to look up the default mapping). Instead I use <code class="language-plaintext highlighter-rouge">/</code> or <code class="language-plaintext highlighter-rouge">?</code> to search, make the change with <code class="language-plaintext highlighter-rouge">c</code> and a motion, exit insert mode with <code class="language-plaintext highlighter-rouge">&lt;C-[&gt;</code>, then use <code class="language-plaintext highlighter-rouge">n</code> or <code class="language-plaintext highlighter-rouge">N</code> to go to the next instance and hit <code class="language-plaintext highlighter-rouge">.</code> to make the change. If the repeated change I want to make is too complex for the dot command to retain, I make use of Vim‚Äôs macros (see <code class="language-plaintext highlighter-rouge">:h complex-repeat</code>).</p>

<p>I do have <a href="https://github.com/bronson/vim-visual-star-search">vim-visual-star-search</a> installed to make <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">#</code> work a bit more intuitively for me, and I certainly could make use of it when finding and replacing, but I haven‚Äôt.</p>

<p>Update: If you‚Äôre really missing Sublime Text‚Äôs multiple cursor feature, <a href="http://www.kevinli.co/posts/2017-01-19-multiple-cursors-in-500-bytes-of-vimscript/">this solid blog post</a> gives some unique recommendations of ways to reproduce Sublime‚Äôs functionality in Vim with a few lines of Vimscript and remapping.</p>

<h3 id="other-vim-defaults-that-i-use-frequently">Other Vim Defaults That I Use Frequently</h3>

<p>Know that when your cursor is on a URL you can hit <code class="language-plaintext highlighter-rouge">gx</code> in normal mode Vim will open that URL in your default browser. I‚Äôve found this to be more helpful than I thought it would be (though there appears to be at least <a href="http://sts10.github.io/2016/02/16/one-solution-to-a-problem-with-vims-gx-command.html">one strange problem with it</a>).</p>

<p><code class="language-plaintext highlighter-rouge">o</code> in visual mode changes which ‚Äúend‚Äù of a visual selection you‚Äôre changing, which I love for its granularity.</p>

<p><code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-l&gt;</code> auto completes an entire line, looking within your current buffer for a line to match. (If you‚Äôre looking for a command to auto-complete lines from your entire project, check out <a href="http://sts10.github.io/2016/01/09/vim-line-complete-with-fzf.html">my post on fzf</a>.) You may also want to checkout the <code class="language-plaintext highlighter-rouge">:copy Ex</code> command, explained in <a href="http://vimcasts.org/episodes/long-range-line-duplication/">this great vimcast</a>.</p>

<h2 id="things-i-dont-really-have-an-answer-for-at-this-point">Things I Don‚Äôt Really Have an Answer For At This Point</h2>

<p>In addition to auto-closing parentheses and brackets that I mentioned above, I don‚Äôt have a good general auto-completion solution setup beyond what <a href="https://github.com/ervandew/supertab">SuperTab</a> gives me. A lot of people seem to use <a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a> or <a href="https://github.com/Shougo/deoplete.nvim">Deoplete</a> for Neovim, but honestly the installation process daunts me a bit, and surely would decrease the portability of my whole setup for a feature that I don‚Äôt think I‚Äôd use a ton. I should probably instead spend time investigating snippets.</p>

<p>Another thing I‚Äôm not sure about is how to best search your entire working directory/project for a bit of code. I think the <a href="http://vimcasts.org/episodes/search-multiple-files-with-vimgrep/">vimgrep</a> command is the default, but I could also use ack or fzf? Again it‚Äôs one of those things I haven‚Äôt really needed yet, though I did use quite a bit when wrestling large Ruby on Rails projects in Sublime Text. With Vim, there‚Äôs always something more to learn.</p>
:ET