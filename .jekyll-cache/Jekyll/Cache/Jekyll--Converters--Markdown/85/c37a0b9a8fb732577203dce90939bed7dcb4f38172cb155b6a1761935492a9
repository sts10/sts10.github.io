I"`<p>I subscribe to <a href="https://cassidoo.co/newsletter/">a wonderful newsletter</a> that, among other things, presents readers with a coding challenge every week.</p>

<p>I had some fun with <a href="https://sts10.github.io/2020/09/28/rust-map-fold.html">last week’s</a>, so I thought I’d do this again, using Rust. So here’s <a href="https://buttondown.email/cassidoo/archive/e203192d-4aa9-48c3-a715-78fb26fe503f">this week’s question</a>:</p>

<blockquote>
  <p>Given an array that was once sorted in ascending order is rotated at some pivot unknown to you beforehand (so [0,2,4,7,9] might become [7,9,0,2,4], for example). Find the minimum value in that array in O(n) or less.</p>
</blockquote>

<p>The way my brain works, this is what jumped at me straight away:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_value_of_drop</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="c">// start loop at 1 so we can always look back one space</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">arr</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// compare this element to the one before, looking for a "drop" in value</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
            <span class="c">// if we found a drop, we know this element is the minimum value</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">// If we made it here and still haven't found the drop, we know the array is </span>
    <span class="c">// such that the first element is the minimum value, so we'll return that</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(In fact, I first wrote is as a <code class="language-plaintext highlighter-rouge">while</code> loop that ended with a <code class="language-plaintext highlighter-rouge">i = i + 1</code> because even though I haven’t written C++ for 20 years, it’s how I learned loops.)</p>

<p>The trick is that we can find the pivot by finding the first element where the <em>previous</em> element is greater. And once we find the pivot, we have also found the minimum value of the array.</p>

<p>I’m pretty sure that code above works – you can <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8b718344d9c6379efe6c3d8dfa805443">test it yourself against a few tests I wrote</a>.</p>

<h2 id="trying-to-use-an-elegant-rust-iterator">Trying to use an elegant Rust iterator</h2>

<p>But, as I managed to do <a href="https://sts10.github.io/2020/09/28/rust-map-fold.html">last week</a>, I wanted to see if there was a more elegant/Rust-y way to look at this problem. First, I tried <code class="language-plaintext highlighter-rouge">cycle</code>, thinking it would help make the problems of (a) running out of elements in the array and (b) checking the first element a bit easier. But I don’t <em>think</em> <code class="language-plaintext highlighter-rouge">cycle</code> really helps here.</p>

<h3 id="peeking">Peeking</h3>

<p>So I looked to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.peekable"><code class="language-plaintext highlighter-rouge">peekable</code></a> / <a href="https://doc.rust-lang.org/std/iter/struct.Peekable.html#method.peek"><code class="language-plaintext highlighter-rouge">peek</code></a>, an iterator I think I had tried to use <a href="https://sts10.github.io/2018/12/07/optimizing-rust-advent-of-code-day-5.html">before</a> without success.</p>

<p>I think the fundamental issue for me with these higher level iterators like peek – specifically the ones that return iterators – is that the examples the documentation gives all use <code class="language-plaintext highlighter-rouge">next()</code> to move through the example array slice. Here’s the peekable/peek example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">xs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.peekable</span><span class="p">();</span>

<span class="c">// peek() lets us see into the future</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.peek</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="mi">1</span><span class="p">));</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span>
</code></pre></div></div>

<p>While what I almost always am in need of is a sturdy example that makes use of a loop like <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">while</code>. (An exception to this is the nice and concise examples for iterators that return a bool, like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all"><code class="language-plaintext highlighter-rouge">all</code></a>  and <code class="language-plaintext highlighter-rouge">any</code>, and those that return something other than an iterator, like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code class="language-plaintext highlighter-rouge">sum</code></a>.) How often do I only want to <code class="language-plaintext highlighter-rouge">next</code> a couple of times? My only guess is that there’s some general way to loop these specialized iterators.</p>

<p>My instincts (most likely from Ruby) is to want to write something like <code class="language-plaintext highlighter-rouge">for (this_element, next_element) in arr.iter().peekable() {</code> and then have access to <code class="language-plaintext highlighter-rouge">this_element</code> and an Option of <code class="language-plaintext highlighter-rouge">next_element</code> in the block (since if you’re at the end of the array slice you won’t have a next_element). (Though I <em>think</em> you can use Rust’s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate">enumerate method</a> like this?) But, of course, this isn’t Ruby.</p>

<p>####</p>

<p>After some haphazard Googling, I found a forum post (I’ve since lost track of) and adapted to this beast, which passed my tests:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_value_of_drop_more_elegant</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">peekable_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.peekable</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">peekable_arr</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">peekable_arr</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">next_element</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">next_element</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">**</span><span class="n">next_element</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But, phew, at first glance I did not like it, nor did I fully understand it (I still might not).</p>

<p>First of all it’s longer and denser than my first solution (I thought these where supposed to be <em>higher</em> level iterators!). And to me it doesn’t look very approachable or readable, especially at first look, particularly that second line, which uses both a <code class="language-plaintext highlighter-rouge">while let</code> and <code class="language-plaintext highlighter-rouge">next</code>, a pattern I wasn’t familiar with.</p>

<p>And despite the borrow checker and I reaching some sort of détente about a year ago, that <code class="language-plaintext highlighter-rouge">**next_element</code> causes me to raise an eyebrow – usually a sign something is off. I <em>think</em> it’s partially due to <code class="language-plaintext highlighter-rouge">peek</code> giving you a <em>reference</em> to the next element (hence the <code class="language-plaintext highlighter-rouge">Some(&amp;&amp;1)</code> in the documentation example). And my best guess is that the other <code class="language-plaintext highlighter-rouge">*</code> is needed because <code class="language-plaintext highlighter-rouge">next()</code> gives references as well, so by that <code class="language-plaintext highlighter-rouge">return</code> line it’s like, double referenced?</p>

<h3 id="an-attempt-at-generalizing">An attempt at generalizing?</h3>

<p>In order to better understand this function that I basically copied from the internet, let’s start slow. Let’s learn about that second line, the one with <code class="language-plaintext highlighter-rouge">while let</code> and the dreaded <code class="language-plaintext highlighter-rouge">next()</code>.</p>

<p>First let’s open the documentation for <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code class="language-plaintext highlighter-rouge">next()</code></a> in a browser tab and let it simmer in our minds.</p>

<p>After thinking about next and while let for a bit, I figured out how to write a simplified example without <code class="language-plaintext highlighter-rouge">peek</code> or any other high level iterator.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iter</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.iter</span><span class="p">();</span>

<span class="c">// A call to next() returns the next value as a reference wrapped in</span>
<span class="c">// an Option...</span>
<span class="c">// assert_eq!(Some(&amp;10), my_iter.next());</span>

<span class="c">// And crucially, despite its name, the first time you call it you</span>
<span class="c">// get the FIRST element.</span>

<span class="c">// We should also note that it "returns None when iteration is finished" </span>

<span class="c">// Since we want to loop through all elements, and we're dealing </span>
<span class="c">// with Options, `while let` actually does fit our use-case pretty well!</span>

<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm on element {}"</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For me, this shows that this “while-let-next” construction is useful at a pretty low-level, in that we can use it as a way to just iterate (whether we’re doing something fancy like <code class="language-plaintext highlighter-rouge">peek</code> or not). Cool!</p>

<p>Next, I knew that <code class="language-plaintext highlighter-rouge">while let</code> was a sort of syntatic sugar for avoiding a formal <code class="language-plaintext highlighter-rouge">match</code> statement and its <code class="language-plaintext highlighter-rouge">None</code> branch – just like <a href="https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html"><code class="language-plaintext highlighter-rouge">if let</code></a>, which <a href="https://sts10.github.io/2018/12/02/lessons-from-first-two-days-of-advent-of-code-2018.html#6-if-let">I’ve met before</a>.</p>

<p>I figured “expanding” the <code class="language-plaintext highlighter-rouge">while let</code> might help me understand what’s going on better. Looking at <a href="https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html">the “Rust by Example” explanation of <code class="language-plaintext highlighter-rouge">while let</code></a>, I was able to expand my simplified example out:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iter</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.iter</span><span class="p">();</span>

<span class="k">loop</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">my_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// if there is indeed a next element... do something</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm on element {}"</span><span class="p">,</span> <span class="n">element</span><span class="p">),</span>
        <span class="c">// if there's not a next element... break</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span> <span class="c">// think this can be None instead of _</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>OK cool, cool. Next, the big task: using what I’ve learned with the simpler example and returning to the peekable code. This is where I learned the unfortunate coincidence of the name of the <code class="language-plaintext highlighter-rouge">next</code> method, mixed with this coding challenge and <code class="language-plaintext highlighter-rouge">peek</code> (which gives you the <em>next</em> <code class="language-plaintext highlighter-rouge">next()</code> element, if you get what I mean).</p>

<p>Here’s how I expanded and annotated that <code class="language-plaintext highlighter-rouge">while let</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_value_of_drop_using_peek_written_out</span><span class="p">(</span><span class="n">vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="c">// let's set up a super neat peekable iterator</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">peekable_vec</span> <span class="o">=</span> <span class="n">vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.peekable</span><span class="p">();</span>
    <span class="c">// start an ole fashion loop!</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c">// this is a crucial line below. We're asking if there are any elements </span>
        <span class="c">// left in our peekable array slice. `next()` is a bit of confusing term</span>
        <span class="c">// here, because later we'll use peek to look at what you might think of </span>
        <span class="c">// as the NEXT element. </span>
        <span class="k">match</span> <span class="n">peekable_vec</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="c">// if there is a "next" element...</span>
            <span class="c">// call it this_element and see if we can peek ahead to the NEXT element</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">this_element</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">peekable_vec</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">next_element</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c">// Yes, there is a NEXT element, so we can do our comparison</span>
                    <span class="c">// because here we have access to both this_element and </span>
                    <span class="c">// next_element</span>
                    <span class="k">if</span> <span class="n">this_element</span> <span class="o">&gt;</span> <span class="n">next_element</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="o">**</span><span class="n">next_element</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c">// No, no NEXT element, so just continue with the loop</span>
                <span class="c">// though we could probably break or return vec[0] here...</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">continue</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="c">// This means we're really at the end of the vector</span>
            <span class="c">// which means the first element is the minimum value</span>
            <span class="c">// break so we get to the last line of the function and</span>
            <span class="c">// return vec[0]</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I think I’m starting to get a handle on it!?</p>

<h2 id="epilogue-a-slightly-tighter-example-using-peek-and-if-let">Epilogue: A slightly tighter example using peek and if let</h2>

<p>One of the great things about Mastodon is if you toot out some Rust code, <a href="https://social.libre.fi/objects/e3fb0226-8458-498d-857b-271bfe6611d6">someone will refactor it further for you</a>. In this case, my above solution can get significantly tighter (and arguably more readable) by replacing the <code class="language-plaintext highlighter-rouge">match</code> statement with an <code class="language-plaintext highlighter-rouge">if let</code>. Behold:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_value_of_drop_more_elegant</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">peekable_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.peekable</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">peekable_arr</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next_element</span><span class="p">)</span> <span class="o">=</span> <span class="n">peekable_arr</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">next_element</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">**</span><span class="n">next_element</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">// If we made it here and still haven't found the drop, we know the array is </span>
    <span class="c">// such that the first element is the minimum value, so we'll return that</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Though I think it’s fair to say it’s still quite a bit more formidable than my very first solution (shout-out to high school comp sci!), which maybe says more about Rust and its iterators than my ability to use them? Maybe I need to work it out in Ruby and compare.</p>
:ET