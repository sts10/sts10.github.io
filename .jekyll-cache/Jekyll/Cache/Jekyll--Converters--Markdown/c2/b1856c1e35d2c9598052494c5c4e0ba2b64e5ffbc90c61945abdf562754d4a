I"•®<p>I‚Äôve got two days of <a href="https://adventofcode.com/2018">Advent of Code 2018</a> under my belt and four stars to show for it! But I‚Äôll be the first to admit that I had plenty of help, so I thought it only fair that I write out some of the things I‚Äôve <em>already</em> learned about Rust.</p>

<p>If you‚Äôre still working on either day 1 or 2 (and there‚Äôs no shame in that‚Ä¶ I‚Äôve yet to get to Day 10), heads up that there are SPOILERS below.</p>

<p>Note: Almost all of these lessons/tricks I snagged from either the code of others or Fediverse friends, some of whom I credit below and some of whom I don‚Äôt. I don‚Äôt think the uncredited will be upset, but if so please drop me a line on <a href="https://octodon.social/@schlink">Octodon</a> or <a href="https://gist.github.com/sts10/4a4e01021b3a5ad42e9b73e0abd7b7e3">elsewhere</a>.</p>

<p>Here‚Äôs <a href="https://github.com/sts10/advent-of-code-2018">my AoC 2018 repo</a> that you might want open as you read.</p>

<h2 id="lessons-from-day-1">Lessons from Day 1</h2>

<ul>
  <li><a href="https://adventofcode.com/2018/day/1">The AoC challenge</a></li>
  <li><a href="https://github.com/sts10/advent-of-code-2018/blob/master/src/bin/day01.rs">My solutions</a></li>
</ul>

<h3 id="1-rust-has-a-cycle-method">1. Rust has a <code class="language-plaintext highlighter-rouge">cycle</code> method</h3>

<p>Did you know <a href="https://doc.rust-lang.org/std/iter/struct.Cycle.html">Rust has a <code class="language-plaintext highlighter-rouge">cycle</code> method</a> (similar to Ruby‚Äôs) that you can use on Vectors? I didn‚Äôt!</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// The cycle method is key here-- it makes the for loop go</span>
<span class="c">// "around the horn" of frequency_changes changes</span>
<span class="k">for</span> <span class="n">frequency_change</span> <span class="n">in</span> <span class="n">frequency_changes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// &lt;loop content here&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-hashsets">2. HashSets</h3>

<p>In part 2 of day 1, I had a long vector that I had to perform a lot of look-ups with (actually a call to <code class="language-plaintext highlighter-rouge">contains</code>). In fact there were so many progressively more cumbersome <code class="language-plaintext highlighter-rouge">contains</code> calls that it took so long to run that I just assumed the compiler was in an infinite loop and I forced it to quit. In reality it was slowing down significantly and I wasn‚Äôt just wasn‚Äôt patient enough (it probably would have taken about 20 to 30 seconds I think).</p>

<p>On the advice of some of my livestream viewers, I replaced the Vector with a HashSet:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c">// ...</span>

<span class="c">// To decrease look-up times, we're going to use a HashSet where I might have</span>
<span class="c">// used a Vector</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">recorded_frequencies</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
</code></pre></div></div>

<p>A <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">HashSet</a> is basically a HashMap with only values (no keys). Sounds like a Vector, right? It sort of is, but my understanding is that, like <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMaps</a>, it‚Äôs optimized for look-ups rather than iteration. In my case, the ‚Äúlook-up‚Äù was a <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.contains"><code class="language-plaintext highlighter-rouge">contains</code></a> call.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">frequency_change</span> <span class="n">in</span> <span class="n">frequency_changes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// find the new (current) frequency</span>
  <span class="n">current_frequency</span> <span class="o">+=</span> <span class="n">frequency_change</span><span class="p">;</span>

  <span class="c">// now check list (Vector) of recorded_frequencies to see if this new_frequency</span>
  <span class="c">// has occurred before</span>
  <span class="k">if</span> <span class="n">recorded_frequencies</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_frequency</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_frequency</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c">// add the new_frequency to the list of recorded_frequencies</span>
  <span class="n">recorded_frequencies</span><span class="nf">.insert</span><span class="p">(</span><span class="n">current_frequency</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-insert-returns-a-bool-of-false-if-value-youre-trying-to-add-is-already-present">3. <code class="language-plaintext highlighter-rouge">insert</code> returns a bool of <code class="language-plaintext highlighter-rouge">false</code> if value you‚Äôre trying to add is already present</h3>

<p>As with a HashMap, you can add to a HashSet with <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.insert"><code class="language-plaintext highlighter-rouge">insert</code></a>.  (as opposed to <code class="language-plaintext highlighter-rouge">push</code>ing to a Vector). Interestingly, again while perusing others‚Äô code, I learned that <code class="language-plaintext highlighter-rouge">insert</code> returns <code class="language-plaintext highlighter-rouge">false</code> if the set already has the value you‚Äôre trying to add. <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.insert">From the docs</a>:</p>

<blockquote>
  <p>Adds a value to the set. If the set did not have this value present, true is returned. If the set did have this value present, false is returned.</p>
</blockquote>

<p>Thus, I think I could have removed that <code class="language-plaintext highlighter-rouge">contains</code> call and just recorded the result of the <code class="language-plaintext highlighter-rouge">insert</code> call. But I ended up not even trying this‚Ä¶ I think my answer would have become less readable.</p>

<h2 id="lessons-from-day-2">Lessons from Day 2</h2>

<ul>
  <li><a href="https://adventofcode.com/2018/day/2">The AoC challenge</a></li>
  <li><a href="https://github.com/sts10/advent-of-code-2018/blob/master/src/bin/day02.rs">My solutions</a></li>
</ul>

<h3 id="4-what-to-borrow-when-nesting-for-loops">4. What to borrow when nesting <code class="language-plaintext highlighter-rouge">for</code> loops</h3>

<p>Day 2‚Äôs 2nd part, at least <a href="https://github.com/sts10/advent-of-code-2018/blob/master/src/bin/day02.rs#L18">for me</a>, involves some tricky nested loops. Crucially, both loops need to iterate through the same data (a Vector of Vectors in the case below).</p>

<p>At first, I tried two <code class="language-plaintext highlighter-rouge">for</code> loops, each in a pattern familiar to me.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">box_id_vec</span> <span class="n">in</span> <span class="n">vector_of_box_ids_as_vecs</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">box_id_vec_to_compare</span> <span class="n">in</span> <span class="n">vector_of_box_ids_as_vecs</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nf">do_two_strs_differ_by_one_character_in_the_same_position</span><span class="p">(</span>
      <span class="n">box_id_vec</span><span class="p">,</span>
      <span class="n">box_id_vec_to_compare</span><span class="p">,</span>
      <span class="p">)</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"found it; {:?} and {:?}"</span><span class="p">),</span> <span class="n">box_id_vec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">box_id_vec_to_compare</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But, given my experience with nested loops in Rust (see <a href="https://github.com/sts10/crackme-rust/blob/master/src/main.rs#L34">this beast</a>), I knew this would through a lot of borrow checker errors (spoiler alert: it did).</p>

<p>I wrestled with it and started adding <code class="language-plaintext highlighter-rouge">&amp;</code>s and <code class="language-plaintext highlighter-rouge">ref</code>s willy nilly, but it just wouldn‚Äôt compile. Eventually I made two distinct copies of the Vector in question, and got the right answer and the gold star.</p>

<p>I left it at that for an hour or two and then started checking solutions from other people doing AoC in Rust. One of them (I can‚Äôt find it now, but here‚Äôs a similar <a href="https://git.gitano.org.uk/personal/dsilvers/aoc.git/tree/2018/src/bin/day2.rs#n33">one</a>) used two <code class="language-plaintext highlighter-rouge">for</code> loops that, rather than iterating through Vectors, instead both looped through <em>ranges</em> of <code class="language-plaintext highlighter-rouge">0..vector.len()</code>. This seems to nicely avoid a lot or the ownership and borrowing issues I hit with the code above.</p>

<p>I also switched the main data source, from a <code class="language-plaintext highlighter-rouge">Vec&lt;Vec&lt;char&gt;&gt;</code> called <code class="language-plaintext highlighter-rouge">vector_of_box_ids_as_vecs</code> to a more simple <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code> called <code class="language-plaintext highlighter-rouge">vector_of_box_ids</code>.</p>

<p>Here‚Äôs my updated Part 2, using ranges/indexes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">number_of_ids</span> <span class="o">=</span> <span class="n">vector_of_box_ids</span><span class="nf">.len</span><span class="p">();</span>
<span class="k">for</span> <span class="n">index_of_box_id</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">index_of_box_id_to_compare</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nf">do_two_strs_differ_by_one_character_in_the_same_position</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id</span><span class="p">],</span>
        <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id_to_compare</span><span class="p">],</span>
        <span class="p">)</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span>
          <span class="s">"found it: {:?} and {:?}"</span><span class="p">,</span>
          <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id</span><span class="p">],</span>
          <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id_to_compare</span><span class="p">]</span>
          <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Obviously you can make the names of the index variables shorter if you like!</p>

<p>I‚Äôm going try to remember this ranges/index trick next time I‚Äôm messing around with nested loops in Rust (I could even use <code class="language-plaintext highlighter-rouge">while</code> loops and handle the iterators myself‚Ä¶).</p>

<p><em>Update</em>: With some help from a Fediverse friend, we got the original <code class="language-plaintext highlighter-rouge">for</code> loop pattern to compile and work. My original attempt was <em>sort of</em> close?</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// new, better version of part 2</span>
<span class="k">for</span> <span class="n">box_id_vec</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">vector_of_box_ids</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">box_id_vec_to_compare</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">vector_of_box_ids</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">common_characters</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_common_characters_if_there_is_only_one_that_is_different</span><span class="p">(</span>
                <span class="n">box_id_vec</span><span class="p">,</span>
                <span class="n">box_id_vec_to_compare</span><span class="p">,</span>
            <span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"common characters are {}"</span><span class="p">,</span> <span class="n">common_characters</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Hooray! (Though I‚Äôm still going to keep that range/index pattern in my bag of tricks.)</p>

<h3 id="5-options-and-zips-oh-my">5. <code class="language-plaintext highlighter-rouge">Option</code>s and <code class="language-plaintext highlighter-rouge">zip</code>s, oh my</h3>

<p>Now let‚Äôs look at the helper function called <code class="language-plaintext highlighter-rouge">find_common_characters_if_there_is_only_one_that_is_different</code>.</p>

<p>Given how I was going to use this function, I figured that the real Rust thing to do would be to have the helper function return an <code class="language-plaintext highlighter-rouge">Option</code>. This also means that it can return a nice-to-use <code class="language-plaintext highlighter-rouge">None</code> whenever it didn‚Äôt find what it was looking for.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_common_characters_if_there_is_only_one_that_is_different</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span><span class="nf">.to_vec</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span><span class="nf">.to_vec</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">common_characters</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">""</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">c</span> <span class="n">in</span> <span class="n">a</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">a_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="n">in</span> <span class="n">b</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">b_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">how_many_characters_are_different</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="n">in</span> <span class="n">a_vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">c</span> <span class="o">!=</span> <span class="n">b_vec</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">how_many_characters_are_different</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">common_characters</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">common_characters</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">how_many_characters_are_different</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">common_characters</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, I didn‚Äôt love all those lines in <code class="language-plaintext highlighter-rouge">find_common_characters_if_there_is_only_one_that_is_different</code> that are used to build the Vectors, but I didn‚Äôt know how to make it any smoother.</p>

<p>Then, again with even more help from aforementioned Fediverse friend, we worked out a much better function, including my first use of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code class="language-plaintext highlighter-rouge">zip</code></a> in Rust, which, I <em>think</em>, basically takes to iterators and zips them into a new iterator with tuples of the original iterators.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">find_common_characters_if_there_is_only_one_that_is_different</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">common_characters</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">""</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">how_many_characters_are_different</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c">// make the zip</span>
    <span class="k">let</span> <span class="n">zipped</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">b</span><span class="nf">.chars</span><span class="p">());</span>

    <span class="c">// iterate through the zip</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a_char</span><span class="p">,</span> <span class="n">b_char</span><span class="p">)</span> <span class="n">in</span> <span class="n">zipped</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">a_char</span> <span class="o">!=</span> <span class="n">b_char</span> <span class="p">{</span>
            <span class="n">how_many_characters_are_different</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c">// add c to the end of common_characters using format!</span>
            <span class="n">common_characters</span><span class="nf">.push</span><span class="p">(</span><span class="n">b_char</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">how_many_characters_are_different</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c">// there are already more than 1 character different,</span>
            <span class="c">// so we don't need to keep checking for difference</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">how_many_characters_are_different</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">common_characters</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here‚Äôs how I use the new function in <code class="language-plaintext highlighter-rouge">main()</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">number_of_ids</span> <span class="o">=</span> <span class="n">vector_of_box_ids</span><span class="nf">.len</span><span class="p">();</span>

<span class="k">for</span> <span class="n">index_of_box_id</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">index_of_box_id_to_compare</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nf">find_common_characters_if_there_is_only_one_that_is_different</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id</span><span class="p">],</span>
            <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id_to_compare</span><span class="p">],</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">common_characters</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"common characters are {}"</span><span class="p">,</span> <span class="n">common_characters</span><span class="p">),</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>I even wrote <a href="https://github.com/sts10/advent-of-code-2018/blob/master/src/bin/day02.rs#L133">a series of tests</a> for <code class="language-plaintext highlighter-rouge">find_common_characters_if_there_is_only_one_that_is_different</code> to make sure it did what we wanted.</p>

<h3 id="6-if-let">6. if let</h3>

<p>Next, <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> informed me that I could use an <code class="language-plaintext highlighter-rouge">if let</code> rather than a <code class="language-plaintext highlighter-rouge">match</code> in <code class="language-plaintext highlighter-rouge">main()</code>. Honestly, I only recently got any sort of a handle of <code class="language-plaintext highlighter-rouge">if let</code>‚Ä¶ it still seems very strange to me. (<a href="https://doc.rust-lang.org/book/second-edition/ch06-03-if-let.html">Here‚Äôs the section in the Rust Book on it</a>.) But admittedly it is pretty concise.</p>

<p>I‚Äôve left the <code class="language-plaintext highlighter-rouge">match</code> statement below, commented out, for reference.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// in main()</span>
<span class="k">let</span> <span class="n">number_of_ids</span> <span class="o">=</span> <span class="n">vector_of_box_ids</span><span class="nf">.len</span><span class="p">();</span>

<span class="k">for</span> <span class="n">index_of_box_id</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">index_of_box_id_to_compare</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">number_of_ids</span> <span class="p">{</span>
    <span class="c">// match find_common_characters_if_there_is_only_one_that_is_different(</span>
    <span class="c">//     &amp;vector_of_box_ids[index_of_box_id],</span>
    <span class="c">//     &amp;vector_of_box_ids[index_of_box_id_to_compare],</span>
    <span class="c">// ) {</span>
    <span class="c">//     Some(common_characters) =&gt; println!("common characters are {}", common_characters),</span>
    <span class="c">//     None =&gt; (),</span>
    <span class="c">// }</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">common_characters</span><span class="p">)</span> <span class="o">=</span>
      <span class="nf">find_common_characters_if_there_is_only_one_that_is_different</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id</span><span class="p">],</span>
          <span class="o">&amp;</span><span class="n">vector_of_box_ids</span><span class="p">[</span><span class="n">index_of_box_id_to_compare</span><span class="p">],</span>
          <span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"common characters are {}"</span><span class="p">,</span> <span class="n">common_characters</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="7-the-entry--and_modify--or_insert-pattern-for-hashmaps">7. The <code class="language-plaintext highlighter-rouge">entry</code> / <code class="language-plaintext highlighter-rouge">and_modify</code> / <code class="language-plaintext highlighter-rouge">or_insert</code> pattern for HashMaps</h3>

<p>If you want to make a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> of counts of things, there‚Äôs some handy methods like <code class="language-plaintext highlighter-rouge">and_modify</code> and <code class="language-plaintext highlighter-rouge">or_insert</code>. When set up in a chain, it searches for a key. If it has the key already, it adds one (or whatever you tell it to do in the block. If the key isn‚Äôt already present, it inserts it with the value you give to <code class="language-plaintext highlighter-rouge">or_insert</code>.</p>

<p>Here‚Äôs <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=ae745b481662b712159fc2edfdc7fd13">a stand-alone example</a>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">text</span> <span class="o">=</span> <span class="s">"aabcdeefghhhij"</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">counts_hashmap</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">char</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">for</span> <span class="n">character</span> <span class="n">in</span> <span class="n">text</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">counts_hashmap</span>
      <span class="nf">.entry</span><span class="p">(</span><span class="n">character</span><span class="p">)</span>
      <span class="nf">.and_modify</span><span class="p">(|</span><span class="n">count</span><span class="p">|</span> <span class="o">*</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nf">.or_insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Character counts in {}</span><span class="se">\n</span><span class="s">{:?}"</span><span class="p">,</span><span class="n">text</span><span class="p">,</span><span class="n">counts_hashmap</span><span class="p">);</span>

  <span class="c">// Now let's sort by counts </span>
  <span class="c">// best way I know how is by making a new vector of tuples</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">count_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">char</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">counts_hashmap</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
  <span class="n">count_vec</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="na">.1</span><span class="nf">.cmp</span><span class="p">(</span><span class="n">a</span><span class="na">.1</span><span class="p">));</span>
  <span class="k">for</span> <span class="n">pair</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">count_vec</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">pair</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could also use <code class="language-plaintext highlighter-rouge">sort_by_key</code> to sort the <code class="language-plaintext highlighter-rouge">count_vec</code>. We‚Äôll need to reverse it to get the highest counts at the top:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Now let's sort by counts </span>
<span class="c">// best way I know how is by making a new vector of tuples</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">count_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">counts_hashmap</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
<span class="n">count_vec</span><span class="nf">.sort_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">_</span><span class="n">c</span><span class="p">,</span> <span class="n">num</span><span class="p">)|</span> <span class="n">num</span><span class="p">);</span>
<span class="n">count_vec</span><span class="nf">.reverse</span><span class="p">();</span>
<span class="k">for</span> <span class="n">pair</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">count_vec</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">pair</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="lesson-8-a-note-on-cargo-and-the-organization-of-my-aoc-repo">Lesson 8: A note on Cargo and the organization of my AoC repo</h2>

<p>At first I had nested git projects, one for the overall project and one for each day (created by running <code class="language-plaintext highlighter-rouge">cargo new</code>). However this was messy and problematic as I had to manage tons of sets of branches, and more with each day. So I learned somethings about Cargo projects and did some reorganization, and now it‚Äôs all within <a href="https://github.com/sts10/advent-of-code-2018">one git project</a>.</p>

<p>Now each day‚Äôs challenge (1 through, hopefully, theoretically, 25) is a Rust executable in <code class="language-plaintext highlighter-rouge">src/bin</code>. Thus the code for, say, Day 2‚Äôs executable is located in <code class="language-plaintext highlighter-rouge">src/bin/day02.rs</code>. To run the Day 2 executable, from the root directory run <code class="language-plaintext highlighter-rouge">cargo run --bin day02</code>. (<code class="language-plaintext highlighter-rouge">cargo run</code> runs <code class="language-plaintext highlighter-rouge">src/main.rs</code>, which doesn‚Äôt have any AoC code in it.)</p>

<p>To run tests, if there are any, run <code class="language-plaintext highlighter-rouge">cargo test --bin day02</code>. The input for each challenge is located in <code class="language-plaintext highlighter-rouge">inputs</code> and named by the day (so for example, <code class="language-plaintext highlighter-rouge">inputs/day02.txt</code>).</p>

<p>And there‚Äôs now only <a href="https://github.com/sts10/advent-of-code-2018">one git project</a>‚Äì the overall one.</p>

<h2 id="bonus-continue-next_line">Bonus: <code class="language-plaintext highlighter-rouge">continue 'next_line</code>???</h2>

<p>In reading others‚Äô solutions to Day 2, I found <a href="https://github.com/anowell/advent-of-code/blob/master/src/day2.rs#L48">something strange</a>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">part2</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">lines</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">line_count</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.len</span><span class="p">();</span>

  <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">line_count</span> <span class="p">{</span>
    <span class="nv">'next_line</span><span class="p">:</span> <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">i</span><span class="o">..</span><span class="n">line_count</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
      <span class="c">// Using bytes is about 25% faster than chars, but we :heart: UTF-8</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="n">in</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="nf">.chars</span><span class="p">())</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">{</span>
          <span class="k">if</span> <span class="n">offset</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">continue</span> <span class="nv">'next_line</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="c">// Only allocate new strings in the inner loop if we found the match</span>
      <span class="c">// Previously, string allocating in the inner loop was ~90% of the execution time</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">offset</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.take</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ret</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.chain</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nf">Err</span><span class="p">(</span><span class="s">"Did not find any strings with only a single character difference"</span><span class="nf">.into</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I‚Äôm assuming that <code class="language-plaintext highlighter-rouge">continue 'next_line;</code> makes the compiler jump up to the line that has <code class="language-plaintext highlighter-rouge">'next_line: for j in i..line_count {</code>. I‚Äôm wondering if that‚Äôs a way to <code class="language-plaintext highlighter-rouge">continue</code> or <code class="language-plaintext highlighter-rouge">break</code> out of multiple loops if we wanted to. Something to checkout.</p>
:ET