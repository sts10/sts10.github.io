I"ˇì<p>Midway through January, 2019, news broke of a large cache of emails and passwords, dubbed <a href="https://www.troyhunt.com/the-773-million-record-collection-1-data-reach/">‚ÄúCollection #1‚Äù</a>, surfacing on the internet. Troy Hunt writes that it includes 772,904,991 unique email addresses and 21,222,975 unique passwords. Wow! Hunt cleaned and loaded the data into his service called HaveIBeenPwned, which allows (non-technical) users to enter either their <a href="https://haveibeenpwned.com/">email</a> or <a href="https://haveibeenpwned.com/Passwords">password(s)</a> to see if their data was included in the breach (or earlier breaches that he‚Äôs cataloged). Hunt‚Äôs total list of passwords now includes more than half a billion unique passwords.</p>

<p>While I‚Äôm reasonably OK entering my email address into the HaveIBeenPwned website, I was a bit more skeptical about entering any of my passwords. Hunt employs something called <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#cloudflareprivacyandkanonymity">k-anonymity</a> to make the password search safer. You can check your passwords this way either by manually entering it in <a href="https://haveibeenpwned.com/Passwords">a webpage</a>, or via <a href="https://haveibeenpwned.com/API/v2">a lovely little API</a>. If using the API, users only need to send the first 5 characters of the SHA-1 hash of their password over the internet. The API then returns all the hashes that have that 5-character prefix, and the user does the rest of the work.</p>

<p>Here‚Äôs <a href="https://www.youtube.com/watch?v=hhUb5iknVJs">a video that does a good job explaining k-anonymity</a>:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/hhUb5iknVJs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Note: For my project, I copied most of this HIBP Password API code from <a href="https://github.com/davidhewitt/password-check">David Hewitt‚Äôs Password Check</a>.</p>

<p>But what if we‚Äôre too paranoid for this type of check?</p>

<h2 id="an-offline-checking-option">An offline checking option</h2>

<p>In addition to this Passwords API, Hunt makes the (very large) text file of the half-billion password list <a href="https://haveibeenpwned.com/Passwords">available to the general public for download</a>, either as a torrent or hosted by Cloudflare. Here are the first 10 lines of the 550-million-line text file (the number after the colon is the number of times that password has appeared in the various breach lists):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7C4A8D09CA3762AF61E59520943DC26494F8941B:23174662
F7C3BC1D808E04732ADF679965CCC34CA7AE3441:7671364
B1B3773A05C0ED0176787A4F1574FF0075F7521E:3810555
5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8:3645804
3D4F2BF07DC1BE38B20CD6E46949A1071F9D0E3D:3093220
7C222FB2927D828AF22F592134E8932480637C0D:2889079
6367C48DD193D56EA7B0BAAD25B19455E529F5EE:2834058
20EABE5D64B0E216796E834F52D61FD0B70332FC:2484157
E38AD214943DAAD1D64C102FAEC29DE4AFE9DA3D:2401761
8CB2237D0679CA88DB6464EAC60DA96345513964:2333232
</code></pre></div></div>

<p>You might be asking: But you said this file had passwords in it. In actuality the file contains <em>hash digests</em> of the passwords, followed by the number of times each password appears in all the collected breaches (the number after the colon).</p>

<p>What‚Äôs a hash and a hash digest? <a href="https://www.youtube.com/watch?v=b4b8ktEV4Bg">Here‚Äôs a good explainer video</a>, <a href="https://www.youtube.com/watch?v=DMtFhACPnTY">another video</a>, and here‚Äôs the <a href="https://en.wikipedia.org/wiki/SHA-1">Wikipedia page</a>. But basically a hash is way to represent a piece of data (in this case, a password) without actually revealing it (though it is ‚Äúguessable‚Äù). An example: If we run the word ‚Äúpassword‚Äù through the SHA-1 hash, we get a ‚Äúdigest‚Äù of <code class="language-plaintext highlighter-rouge">5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8</code> (which was the 4th most common password in the breach with a whopping 3,645,804 appearances).</p>

<p>To generate this ‚Äúhash digest‚Äù, we run a numeric representation of the word ‚Äúpassword‚Äù through the Secure Hash Algorithm 1, aka SHA-1. SHA-1, which was designed by the NSA, is an example of a one-way mathematical function, which Wikipedia <a href="https://en.wikipedia.org/wiki/One-way_function">defines</a>:</p>

<blockquote>
  <p>In computer science, a one-way function is a function that is easy to compute on every input, but hard to invert given the image of a random input. Here, ‚Äúeasy‚Äù and ‚Äúhard‚Äù are to be understood in the sense of computational complexity theory, specifically the theory of polynomial time problems. Not being one-to-one is not considered sufficient of a function for it to be called one-way.</p>
</blockquote>

<p>You can generate your own SHA-1 hash digests <a href="https://passwordsgenerator.net/sha1-hash-generator/">here</a>, though I would not recommend typing your real passwords into that website.</p>

<p>If that went a bit over your head don‚Äôt worry too much about it for now ‚Äì we‚Äôll press on.</p>

<h2 id="what-i-wanted-to-do">What I wanted to do</h2>

<p>After the recent breach, I was curious to check my passwords against the list, but I‚Äôm a bit paranoid, so, rather than paste my passwords into the Have I Been Pwned website or use the API that uses k-anonymity, I wanted to chose a third option: download the big text file and check my passwords against it offline, nice and safely.</p>

<p>I use a password manager called KeePassXC, so all of my passwords are stored in an encrypted file ‚Äì a KeePass database ‚Äì and I use a program called <a href="https://keepassxc.org/">KeePassXC</a>, a free and open-source password manager, to manage them (I wrote <a href="https://sts10.github.io/2017/06/27/keepassxc-setup-guide.html">a beginner‚Äôs user guide to KeePassXC</a> a while back if you‚Äôre interested!). So ideally, to check my passwords against the big list, I‚Äôd have a tool that checks all the passwords in a given KeePass database against the entire HaveIBeenPwned list of passwords, preferably against the downloaded file (i.e. ‚Äúoffline‚Äù), rather than the API. In other words something similar to <a href="https://support.1password.com/watchtower/">1Password‚Äôs Watchtower feature</a>, but preferably offline.</p>

<p>After poking around a bit I decided to write it myself in Rust, with <a href="https://github.com/davidhewitt/password-check/blob/master/src/main.rs">this script</a> and <a href="https://github.com/sseemayer/keepass-rs">this crate</a> as useful references.</p>

<h2 id="what-i-wrote">What I wrote</h2>

<p><a href="https://github.com/sts10/medic">Medic</a> is a Rust CLI that can perform a variety of ‚Äúhealth‚Äù checks on a KeePass database. It works! But nevertheless I‚Äôm going to give a big ol‚Äô ‚Äúbuyer beware‚Äù on it ‚Äì I am a social media producer by trade, and have never written software that deals so directly with sensitive data before. (Of course, part of the promise of Rust is that it enables more people to write ‚Äúsafe‚Äù code, so this was a natural challenge for me.)</p>

<p>Medic can check the passwords of a given KeePass database in four ways:</p>

<ol>
  <li>Check passwords against the HaveIBeenPwned password database, via the HaveIBeenPwned API</li>
  <li>Check passwords against a file of password hashes. This requires users to download a large list of SHA-1 hashes of breached or compromised passwords. I tailored it to work with the Pwned Passwords lists from HaveIBeenPwned, which anyone can download <a href="https://haveibeenpwned.com/Passwords">here</a>. Medic will then display a list of any passwords from the given KeePass database that also appear in the list of breached passwords.</li>
  <li>Check for weak passwords, using <a href="https://github.com/dropbox/zxcvbn">zxcvbn</a></li>
  <li>Check for duplicate passwords</li>
</ol>

<p>For more on usage and setup, it‚Äôs best to refer to the <a href="https://github.com/sts10/medic/blob/master/readme.markdown">ReadMe</a>. In this post I‚Äôm going to go over some of my Rust code and what it does.</p>

<h2 id="but-is-this-useful">But is this useful?</h2>

<p>I have run my personal KeePass database through the program (actually I exported my database to a CSV file and ran that through the program ‚Äì <a href="https://github.com/sts10/medic#how-i-chose-to-use-this-tool">I outline the steps I actually took in the README</a>). It found a few old passwords (that I was still using) among the HIBP list, though I should note that I did not find any of my passwords that I used KeePassXC (or 1Password, which I sometimes use for mobile) to randomly generate on the breach list.</p>

<p>There is an open question of the usefulness of this kind of check ‚Äì the logic of the question is something like ‚ÄúWouldn‚Äôt a KeePass user not have any common passwords, thus a check against a breach list like this be pointless?‚Äù My tentative answer is that even the strongest of passwords can be exposed. Sure, it may only appear on the list once, but it‚Äôs still there, and a tool like Medic is one of the safer yet moderately efficient ways I can think of to learn if that‚Äôs true or not for any of your passwords. Plus, as mentioned, 1Password has a similar tool called Watchtower.</p>

<h2 id="reading-a-keepassxc-database">Reading a KeePassXC database</h2>

<p>With the <a href="https://github.com/sseemayer/keepass-rs">keepass-rs crate</a> loaded up, unlocking and reading the entries of KeePass database was pretty easy. Below is an early version of a function that did just that:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get_entries_from_keepass_db</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">let</span> <span class="n">db_pass</span> <span class="o">=</span>
        <span class="nn">rpassword</span><span class="p">::</span><span class="nf">read_password_from_tty</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="s">"Enter the password to your KeePass database: "</span><span class="p">))</span>
        <span class="nf">.unwrap</span><span class="p">();</span>
    <span class="c">// Open KeePass database</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Attempting to unlock your KeePass database..."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">db</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
        <span class="nf">.map_err</span><span class="p">(</span><span class="nn">OpenDBError</span><span class="p">::</span><span class="n">Io</span><span class="p">)</span>
        <span class="nf">.and_then</span><span class="p">(|</span><span class="k">mut</span> <span class="n">db_file</span><span class="p">|</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">db_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db_pass</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
        <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Reading your KeePass database..."</span><span class="p">);</span>
    <span class="c">// Iterate over all Nodes</span>
    <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">db</span><span class="py">.root</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">node</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Entry</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">this_entry</span> <span class="o">=</span> <span class="n">Entry</span> <span class="p">{</span>
                    <span class="n">title</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_title</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="n">username</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_username</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="n">pass</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_password</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="n">digest</span><span class="p">:</span> <span class="nn">sha1</span><span class="p">::</span><span class="nn">Sha1</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">e</span><span class="nf">.get_password</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">())</span>
                       <span class="nf">.digest</span><span class="p">()</span>
                       <span class="nf">.to_string</span><span class="p">()</span>
                       <span class="nf">.to_uppercase</span><span class="p">(),</span>
                <span class="p">};</span>
                <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="n">this_entry</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">entries</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once the entry‚Äôs data is exposed (in this case, in <code class="language-plaintext highlighter-rouge">e</code>) I ‚Äúbuild‚Äù a new Entry struct called <code class="language-plaintext highlighter-rouge">this_entry</code> ‚Äì we use some emthods laid out in the keepass-rs documentation to get at the title, username and <code class="language-plaintext highlighter-rouge">pass</code>word. Then we use the password again to create a SHA-1 hash digest that we‚Äôll also need later. Once the entry is built I <code class="language-plaintext highlighter-rouge">push</code> the entry into a Vector simply called <code class="language-plaintext highlighter-rouge">entries</code>.</p>

<p>For reference, here‚Äôs the definition of the <code class="language-plaintext highlighter-rouge">Entry</code> struct:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Entry</span> <span class="p">{</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">url</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">pass</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">digest</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Believe it or not, the above code represents an early, partially simplified version. Below I discuss how the current version of Medic handles this task (the <code class="language-plaintext highlighter-rouge">Entry</code> struct definition remained unchanged though).</p>

<h3 id="how-i-read-in-a-keepass-database-in-the-current-version-of-medic">How I read in a KeePass database in the current version of Medic</h3>

<p>As I wrote more code and added more features to the program ‚Äì including the ability to take a keyfile or a CSV export of the user‚Äôs database, I broke this ‚ÄúRead KeePass database entries into Vector of Structs‚Äù task into a couple of functions, all located in <code class="language-plaintext highlighter-rouge">src/lib.rs</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_entries</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span> <span class="n">keyfile_path</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">file_path</span><span class="nf">.extension</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_str</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">db_pass</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">if</span> <span class="n">file_extension</span> <span class="o">!=</span> <span class="s">"csv"</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span>
            <span class="nn">rpassword</span><span class="p">::</span><span class="nf">read_password_from_tty</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span>
                <span class="s">"Enter the password to your KeePass database: "</span><span class="p">,</span>
            <span class="p">))</span>
            <span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="n">file_extension</span> <span class="o">!=</span> <span class="s">"csv"</span> <span class="o">&amp;&amp;</span> <span class="n">db_pass</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">build_entries_from_keepass_db</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">db_pass</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">keyfile_path</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">build_entries_from_csv</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">build_entries_from_keepass_db</span><span class="p">(</span>
        <span class="n">file_path</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
        <span class="n">db_pass</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">keyfile_path</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Attempting to unlock your KeePass database..."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">db</span> <span class="o">=</span> <span class="nf">unlock_keepass_database</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">db_pass</span><span class="p">,</span> <span class="n">keyfile_path</span><span class="p">);</span>
    <span class="c">// Iterate over all Groups and Nodes</span>
    <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">db</span><span class="py">.root</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">node</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">GroupNode</span><span class="p">(</span><span class="mi">_</span><span class="n">g</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c">// println!("Saw group '{}'", g.name);</span>
            <span class="p">}</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">EntryNode</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">this_entry</span> <span class="o">=</span> <span class="n">Entry</span> <span class="p">{</span>
<span class="n">title</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_title</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
           <span class="n">username</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_username</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
           <span class="n">url</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get</span><span class="p">(</span><span class="s">"URL"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
           <span class="n">pass</span><span class="p">:</span> <span class="n">e</span><span class="nf">.get_password</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
           <span class="n">digest</span><span class="p">:</span> <span class="nn">sha1</span><span class="p">::</span><span class="nn">Sha1</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">e</span><span class="nf">.get_password</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">())</span>
               <span class="nf">.digest</span><span class="p">()</span>
               <span class="nf">.to_string</span><span class="p">()</span>
               <span class="nf">.to_uppercase</span><span class="p">(),</span>
                <span class="p">};</span>
                <span class="k">if</span> <span class="n">this_entry</span><span class="py">.pass</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
                    <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="n">this_entry</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Successfully read KeePass database!"</span><span class="p">);</span>
    <span class="n">entries</span>
<span class="p">}</span>

<span class="c">// helper function that does the actual unlocking</span>
<span class="k">fn</span> <span class="nf">unlock_keepass_database</span><span class="p">(</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
        <span class="n">db_pass</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">keyfile_path</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">keepass</span><span class="p">::</span><span class="n">Database</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">keyfile</span> <span class="o">=</span> <span class="n">keyfile_path</span><span class="nf">.map</span><span class="p">(|</span><span class="n">kfp</span><span class="p">|</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">kfp</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>

    <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span>               <span class="c">// the database</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                               <span class="c">// password</span>
            <span class="n">keyfile</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">f</span><span class="p">|</span> <span class="n">f</span> <span class="k">as</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">dyn</span> <span class="n">Read</span><span class="p">),</span> <span class="c">// keyfile</span>
            <span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error opening database: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When I started this project the keepass-rs crate wasn‚Äôt able to unlock KeePass databases that were locked with keyfiles. Feeling lucky, I opened <a href="https://github.com/sseemayer/keepass-rs/issues/8">an issue</a> on the crate‚Äôs GitHub repo and just hours later the maintainer responded. The next day he wrote the feature into the crate ‚Äì basically <code class="language-plaintext highlighter-rouge">Database::open</code> takes an optionally third argument ‚Äì , and I bumped the version in my <code class="language-plaintext highlighter-rouge">Cargo.toml</code> to <code class="language-plaintext highlighter-rouge">0.3.1</code>. Open source ftw!</p>

<p>At this point I could read the entries of a KeePass database into a Vector of custom-made <code class="language-plaintext highlighter-rouge">Entry</code> objects (even if the KeePass database was locked with a keyfile). Sweet! Onward!</p>

<h2 id="using-the-haveibeenpwned-api-to-offer-users-an-online-check">Using the HaveIBeenPwned API to offer users an online check</h2>

<p>As mentioned above, HIBP offers an API To check passwords. You‚Äôre welcome to checkout the code to the API/‚Äùonline‚Äù check, but again, I mostly copied it from <a href="https://github.com/davidhewitt/password-check">this very clean project</a>. Hope that‚Äôs cool, David!</p>

<h2 id="the-offline-check-splitting-the-work-into-chunks">The offline check: Splitting the work into chunks</h2>

<p>Once I successfully downloaded the 11 GB file of passwords and extracted it to a usable <code class="language-plaintext highlighter-rouge">txt</code> file (22.6 GB), I was able to begin work on the offline check.</p>

<p>Here are the first 10 lines:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7C4A8D09CA3762AF61E59520943DC26494F8941B:23174662
F7C3BC1D808E04732ADF679965CCC34CA7AE3441:7671364
B1B3773A05C0ED0176787A4F1574FF0075F7521E:3810555
5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8:3645804
3D4F2BF07DC1BE38B20CD6E46949A1071F9D0E3D:3093220
7C222FB2927D828AF22F592134E8932480637C0D:2889079
6367C48DD193D56EA7B0BAAD25B19455E529F5EE:2834058
20EABE5D64B0E216796E834F52D61FD0B70332FC:2484157
E38AD214943DAAD1D64C102FAEC29DE4AFE9DA3D:2401761
8CB2237D0679CA88DB6464EAC60DA96345513964:2333232
</code></pre></div></div>

<p>The format is <code class="language-plaintext highlighter-rouge">&lt;SHA-1 hash of the password&gt;</code> and then a colon, then the number of times that particular password appeared in the various breaches (a number I didn‚Äôt have much interest in). The last 10 lines are very similar to the first 10, except that all of the number-of-appearances are <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>Troy Hunt <a href="https://www.troyhunt.com/introducing-306-million-freely-downloadable-pwned-passwords/#whyhashes">explains why he uses SHA-1 for this project</a>:</p>

<blockquote>
  <p>Each of the‚Ä¶ passwords is being provided as a SHA1 hash. What this means is that anyone using this data can take a plain text password from their end (for example during registration, password change or at login), hash it with SHA1 and see if it‚Äôs previously been leaked. It doesn‚Äôt matter that SHA1 is a fast algorithm unsuitable for storing your customers‚Äô passwords with because that‚Äôs not what we‚Äôre doing here, it‚Äôs simply about ensuring the source passwords are not immediately visible.</p>
</blockquote>

<h3 id="back-to-the-code">Back to the code</h3>

<p>So, to review, our task is to open up a KeePass database (see above), make SHA-1 hashes (sometimes referred to more specifically as ‚Äúdigests‚Äù) of all the passwords (I do this when I build the <code class="language-plaintext highlighter-rouge">Entry</code> objects), then see if they appear in this 550-million-line text document.</p>

<p>My first problem: figuring out how to read this massive amount of data in to my Rust program in order to work with it.</p>

<p>In my first attempt, I brazenly <a href="https://github.com/sts10/medic/blob/1770df4d4f5383768c466847c669e95f3e0451fd/src/main.rs#L197">tried to read all 550 million hashes into a single, massive Vector</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">read_by_line</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="nf">.trim_matches</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'\''</span> <span class="p">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">res</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">line_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">file</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">line_number</span> <span class="o">=</span> <span class="n">line_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Reading line #{:?}"</span><span class="p">,</span> <span class="n">line_number</span><span class="p">);</span>
        <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">line</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you might guess, this slowly but surely tried to fill up 22.6 GB of my RAM. (While I have 32 GB on this machine (rah!), this obviously wasn‚Äôt a viable method.)</p>

<p>I had a few ideas of how to solve this issue, but <a href="https://fosstodon.org/@codesections/101463247584610406">a Fediverse friend</a> helped me decide to split the data into chunks. After some testing I did later, I found that 10 million lines per chunk was a pretty good size.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">check_database_offline</span><span class="p">(</span><span class="n">passwords_file_path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">this_chunk</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">breached_entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">passwords_file_path</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">res</span><span class="p">,</span>
      <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="c">// times via `cargo test --release can_check_offline --no-run &amp;&amp; time cargo test --release can_check_offline -- --nocapture`</span>
  <span class="c">// let chunk_size = 1_000_000; // real 1m24.709s</span>
  <span class="c">// let chunk_size = 20_000_000; // real 1m13.159s</span>
  <span class="k">let</span> <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">10_000_000</span><span class="p">;</span> <span class="c">// real 1m14.613s</span>

  <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">file</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">this_chunk</span><span class="nf">.push</span><span class="p">(</span><span class="n">line</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="k">if</span> <span class="n">this_chunk</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">chunk_size</span> <span class="p">{</span>
      <span class="k">match</span> <span class="nf">check_this_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_chunk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">mut</span> <span class="n">vec_of_breached_entries</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
          <span class="n">breached_entries</span><span class="nf">.append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec_of_breached_entries</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"found no breached entries in this chunk"</span><span class="p">),</span>
      <span class="p">}</span>
      <span class="n">this_chunk</span><span class="nf">.clear</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="n">breached_entries</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">for line in files.lines()</code> loop loops through each line of the file, <code class="language-plaintext highlighter-rouge">push</code>ing them into <code class="language-plaintext highlighter-rouge">this_chunk</code>. When the <code class="language-plaintext highlighter-rouge">len</code> of the chunk gets larger than the designated <code class="language-plaintext highlighter-rouge">chunk_size</code>, it dips into that <code class="language-plaintext highlighter-rouge">match</code> statement, which sends <code class="language-plaintext highlighter-rouge">this_chunk</code>, as well as a reference to the users <code class="language-plaintext highlighter-rouge">entries</code>, to another function called <code class="language-plaintext highlighter-rouge">check_this_chunk</code>. If <code class="language-plaintext highlighter-rouge">check_this_chunk</code> finds any passwords from your KeePass entries in that chunk, it returns them in a <code class="language-plaintext highlighter-rouge">Result</code>, then <code class="language-plaintext highlighter-rouge">append</code>s them to a Vector called <code class="language-plaintext highlighter-rouge">breached_entries</code> (if no matches, does nothing). Next, <em>crucially</em> it <code class="language-plaintext highlighter-rouge">clear</code>s <code class="language-plaintext highlighter-rouge">this_chunk</code> ‚Äì removing all the digests from memory ‚Äì before continuing through the big file.</p>

<p>Then it moves on to building the next chunk.</p>

<p>The result is that we never have more than 10 million hash digests stored in RAM at one time.</p>

<p>This works pretty well! Running rustc in release mode, it takes about 70 seconds to check a test KeePass database of 5 or so entries. To check my ~80-entry database, it was more like 2 minutes. Not terrible!</p>

<h2 id="doing-the-checking">Doing the checking</h2>

<p>Once I got this chunk thing figured out, doing the actual hash digest comparisons was relatively easier ‚Äì I used nested <code class="language-plaintext highlighter-rouge">for</code> loops.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">check_this_chunk</span><span class="p">(</span><span class="n">entries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Entry</span><span class="p">],</span> <span class="n">chunk</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">breached_entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">chunk</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">this_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">line</span><span class="p">[</span><span class="o">..</span><span class="mi">40</span><span class="p">];</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">entries</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">this_hash</span> <span class="o">==</span> <span class="n">entry</span><span class="py">.digest</span> <span class="p">{</span>
                <span class="n">breached_entries</span><span class="nf">.push</span><span class="p">(</span><span class="n">entry</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">breached_entries</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I made it a little easier on myself here and used <code class="language-plaintext highlighter-rouge">clone()</code> so that I wouldn‚Äôt have to worry as much about ownership. I figured this was OK resource-wise, since (hopefully) no one‚Äôs going to have thousands or even hundreds of breached entries in a single KeePass database.</p>

<p>In an effort to speed up this check, I did experiment a little with <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">Rust‚Äôs <code class="language-plaintext highlighter-rouge">HashSet</code></a> collection type, but ‚Äì the way I implemented them at least ‚Äì it wasn‚Äôt noticeably faster. Could be a good future project though, along with adding threading.</p>

<h3 id="adding-a-progress-bar-and-learning-that-line-counting-is-pretty-slow">Adding a progress bar and learning that line counting is pretty slow?!</h3>

<p>While this offline check worked reasonably well, it still took 1 to 3 minutes to complete. In <a href="https://sts10.github.io/2018/12/07/optimizing-rust-advent-of-code-day-5.html">my previous experience</a>, if you work hard enough you can speed Rust up significantly, but I figured before banging my head on that it‚Äôd be fun to see if I could implement a progress bar.</p>

<p>I found two crates for just this: <a href="https://github.com/a8m/pb">pb</a> and <a href="https://github.com/mitsuhiko/indicatif">indicatif</a>. I found indicatif‚Äôs API a little more sensible, and it allowed for colors, so I went with that (though pb seems more lightweight).</p>

<p><img src="https://github.com/mitsuhiko/indicatif/raw/master/screenshots/download.gif" alt="GIF of an example progress bar" /></p>

<p>I hit a sticking point here though: both progress bar libraries require you to set some value for when the progress bar should be done. For example, if you‚Äôre cranking through 550M lines, you might want to set this value to <code class="language-plaintext highlighter-rouge">550_000_000</code>, and you‚Äôd call <code class="language-plaintext highlighter-rouge">pb.inc(chunk_size as u64)</code> each time you finished checking a chunk. Obviously hardcoding the <code class="language-plaintext highlighter-rouge">550_000_000</code> is one option here, but it‚Äôs not ideal ‚Äì what if the file HaveIBeenPwned offers gets larger over time?</p>

<p>So I tried having Rust count the lines of the inputed file ‚Äì something like <code class="language-plaintext highlighter-rouge">f.lines().unwrap().len()</code> ‚Äì but this takes a pretty long time for a 550-million-line text file ‚Äì like a minute at least. Since I was only doing this for the progress bar, that was unacceptable. But rather than ditch the progress bar or resort to hard-coding a value, I ended up using <code class="language-plaintext highlighter-rouge">f.metadata.unwrap().len()</code> to get the <em>number of bytes</em> of the file. This call is much quicker, which kind of makes sense intuitively?</p>

<h4 id="counting-by-bytes-rather-than-lines">Counting by bytes, rather than lines</h4>

<p>My next problem was I had to estimate the size of each chunk in bytes rather than in numbers of lines. 500 MB felt like a good RAM requirement for the user ‚Äì I felt OK hard-coding that value. But now I had to figure out how to check the byte size of a Rust Vector as I added to it.</p>

<p>I kind of forget how I did this ‚Äì maybe <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html"><code class="language-plaintext highlighter-rouge">std::mem::size_of</code></a> ‚Äì but by my first measure I found that one line of the text file was 24 bytes. But when I tried using this value, the progress bar would get to 50% and the process would end, so I just doubled it to <code class="language-plaintext highlighter-rouge">48</code> and went with that. Again, if you have a more scientific way of correctly reading the size of a Rust String stored in a Vector, let me know.</p>

<p>Anyway, here‚Äôs where I landed:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">check_database_offline</span><span class="p">(</span>
        <span class="n">passwords_file_path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">this_chunk</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">breached_entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">passwords_file_path</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">res</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">passwords_file_size</span> <span class="o">=</span> <span class="n">f</span><span class="nf">.metadata</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">500_000_000</span><span class="p">;</span> <span class="c">// real 1m7.686s</span>

    <span class="k">let</span> <span class="n">pb</span> <span class="o">=</span> <span class="nn">ProgressBar</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">passwords_file_size</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">progress_bar</span> <span class="p">{</span>
        <span class="n">pb</span><span class="nf">.set_style</span><span class="p">(</span>
                <span class="nn">ProgressStyle</span><span class="p">::</span><span class="nf">default_bar</span><span class="p">()</span>
                <span class="nf">.template</span><span class="p">(</span><span class="s">"{spinner} [{elapsed_precise}] [{bar:40}] ({eta})"</span><span class="p">),</span>
                <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">file</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">this_line</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">()[</span><span class="o">..</span><span class="mi">40</span><span class="p">]</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="n">this_chunk</span><span class="nf">.push</span><span class="p">(</span><span class="n">this_line</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">this_chunk</span><span class="nf">.len</span><span class="p">()</span> <span class="o">*</span> <span class="mi">48</span> <span class="o">&gt;</span> <span class="n">chunk_size</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nf">check_this_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_chunk</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="k">mut</span> <span class="n">vec_of_breached_entries</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">breached_entries</span><span class="nf">.append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec_of_breached_entries</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"found no breached entries in this chunk"</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">progress_bar</span> <span class="p">{</span>
                <span class="n">pb</span><span class="nf">.inc</span><span class="p">(</span><span class="n">chunk_size</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">this_chunk</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">progress_bar</span> <span class="p">{</span>
        <span class="n">pb</span><span class="nf">.finish_with_message</span><span class="p">(</span><span class="s">"Done."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">breached_entries</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="checking-for-weak-passwords-with-zxcvbn">Checking for weak passwords with zxcvbn</h2>

<p>Next, since I had already done all the work to read in a user‚Äôs passwords, I figured I might as well build out an option to check their database for <em>weak</em> passwords.</p>

<p>Troy Hunt actually <a href="https://www.troyhunt.com/introducing-306-million-freely-downloadable-pwned-passwords/">suggests doing this in his original blog post about the password list</a> in conjunction with a HaveIBeenPwned check ‚Äì he recommends using <a href="https://github.com/dropbox/zxcvbn">zxcvbn</a>, a ‚Äúlow-budget password strength checker‚Äù from Dropbox.</p>

<p>Luckily, a few months ago I used Rust to make <a href="https://github.com/sts10/password-strength-checker">this little password checker</a> that uses <a href="https://github.com/shssoichiro/zxcvbn-rs">a Rust port of zxcvbn</a>. The Rust port is pretty straight-forward to use. Here are the two functions I needed:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">check_for_and_display_weak_passwords</span><span class="p">(</span><span class="n">entries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Entry</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">estimate</span> <span class="o">=</span> <span class="nf">zxcvbn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="py">.pass</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="n">entry</span><span class="py">.title</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.username</span><span class="p">])</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="c">// estimate.score gives is a 0 to 4 score of the password</span>
        <span class="k">if</span> <span class="n">estimate</span><span class="py">.score</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Your password for {} is weak."</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
            <span class="nf">give_feedback</span><span class="p">(</span><span class="n">estimate</span><span class="py">.feedback</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">--------------------------------"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">give_feedback</span><span class="p">(</span><span class="n">feedback</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">zxcvbn</span><span class="p">::</span><span class="nn">feedback</span><span class="p">::</span><span class="n">Feedback</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">feedback</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span> <span class="o">=</span> <span class="n">feedback</span><span class="py">.warning</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Warning: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">warning</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Suggestions:"</span><span class="p">);</span>
            <span class="k">for</span> <span class="n">suggestion</span> <span class="n">in</span> <span class="n">feedback</span><span class="py">.suggestions</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"   - {}"</span><span class="p">,</span> <span class="n">suggestion</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"No suggestions."</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Two cool things here: First, that second argument to <code class="language-plaintext highlighter-rouge">zxcvbn</code> is a Vector of related words, like username or service title, to assist zxcvbn in estimating the password‚Äôs strength. For example, <code class="language-plaintext highlighter-rouge">github_rocks123</code> might be an OK password for Tumblr, but it‚Äôs a worse choice for GitHub.</p>

<p>Second, the function returns ‚Äúfeedback‚Äù, which I wrote a helper function to display. Examples of feedback are like, ‚ÄúDon‚Äôt use dates‚Äù.</p>

<h2 id="using-a-hashmap-to-find-and-organize-duplicate-passwords">Using a HashMap to find and organize duplicate passwords</h2>

<p>Next, I figured I‚Äôd offer the option of finding re-used or duplicate passwords. To do this, I used a Rust HashMap and this neat <code class="language-plaintext highlighter-rouge">entry</code>/<code class="language-plaintext highlighter-rouge">and_modify</code>/<code class="language-plaintext highlighter-rouge">or_insert</code> pattern <a href="https://sts10.github.io/2018/12/02/lessons-from-first-two-days-of-advent-of-code-2018.html#7-the-entry--and_modify--or_insert-pattern-for-hashmaps">I‚Äôve used before</a> that‚Äôs great for counting things.</p>

<p>To be a <em>little</em> safer, I decided to use the password hash digests for the keys of the HashMap (called <code class="language-plaintext highlighter-rouge">digest_map</code> below). The values are a Vector (<code class="language-plaintext highlighter-rouge">group</code>) of all the entries whose password digest is the same. So if none of your KeePass database‚Äôs entries share passwords, all of the keys of this HashMap will only have one Entry in their attached Vectors. But if, say, three entries share a password, the digest of that password will be a key and its value will be a Vector with 3 Entries in it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">make_digest_map</span><span class="p">(</span><span class="n">entries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Entry</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">digest_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">digest_map</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">entry</span><span class="nf">.clone</span><span class="p">()</span><span class="py">.digest</span><span class="p">)</span>
            <span class="nf">.and_modify</span><span class="p">(|</span><span class="n">vec</span><span class="p">|</span> <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">entry</span><span class="nf">.clone</span><span class="p">()))</span>
            <span class="nf">.or_insert_with</span><span class="p">(||</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">entry</span><span class="nf">.clone</span><span class="p">()]);</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">digest_map</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Clippy told me "warning: parameter of type `HashMap` should be generalized over different hashers"</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">present_duplicated_entries</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">BuildHasher</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">digest_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">has_duplicated_entries</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">group</span> <span class="n">in</span> <span class="n">digest_map</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// print if there is more than 1 element in the vector, since that represents a repeated password</span>
        <span class="k">if</span> <span class="n">group</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"The following entries have the same password:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">group</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"   - {}"</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">has_duplicated_entries</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">has_duplicated_entries</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Password re-use is bad. Change passwords until you have no duplicates."</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Good job -- no password reuse detected!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Gonna be straight with you: I‚Äôm not 100% sure about that <code class="language-plaintext highlighter-rouge">.or_insert_with(|| vec![entry.clone()]);</code> line ‚Äì it was a Clippy suggestion. I had a simple <code class="language-plaintext highlighter-rouge">or_insert</code> call.</p>

<h2 id="making-it-a-grown-up-rust-cli-with-structopt">Making it a grown-up Rust CLI with <code class="language-plaintext highlighter-rouge">structopt</code></h2>

<p>In earlier versions, Medic presented users with a menu and asked for a numerical choice input.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To check your KeePass database's passwords, do you want to:

==&gt; 1. Check for weak passwords
==&gt; 2. Check for duplicate passwords
==&gt; 3. Check OFFLINE for breached passwords: Give me a database of SHA-1 hashed passwords to check your KeePass database against
==&gt; 4. Check ONLINE for breached passwords: I will hash your passwords and send the first 5 characters of each hash over the internet to HaveIBeenPwned, in order to check if they've been breached.
</code></pre></div></div>

<p>But as I learned more about Rust command line interfaces, I saw there are a handful of command line argument parsers that people use to create their CLIs, which gives the ecosystem of Rust CLIs a nice uniformity. These parsers include <a href="https://github.com/clap-rs/clap">clap</a> and <a href="https://github.com/TeXitoi/structopt">structopt</a>, among others. I decided to go with structopt.</p>

<p><code class="language-plaintext highlighter-rouge">structopt</code> requires you to define a <code class="language-plaintext highlighter-rouge">struct</code> called <code class="language-plaintext highlighter-rouge">Opt</code> in <code class="language-plaintext highlighter-rouge">src/main.rs</code>, in which we outline the options, flags, and arguments that our CLI will take. We can also provide documentation notes (denoted by the triple <code class="language-plaintext highlighter-rouge">///</code>) that will populate the <code class="language-plaintext highlighter-rouge">--help</code> output.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// excerpt from src/main.rs</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">structopt</span><span class="p">;</span>
<span class="c">// ...</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">structopt</span><span class="p">::</span><span class="n">StructOpt</span><span class="p">;</span>

<span class="c">/// Medic</span>
<span class="nd">#[derive(StructOpt,</span> <span class="nd">Debug)]</span>
<span class="nd">#[structopt(name</span> <span class="nd">=</span> <span class="s">"medic"</span><span class="nd">)]</span>
<span class="k">struct</span> <span class="n">Opt</span> <span class="p">{</span>
    <span class="c">/// Give verbose output</span>
    <span class="nd">#[structopt(short</span> <span class="nd">=</span> <span class="s">"v"</span><span class="nd">,</span> <span class="nd">long</span> <span class="nd">=</span> <span class="s">"verbose"</span><span class="nd">)]</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="c">/// Provide key file, if unlocking the KeePass databases requires one</span>
    <span class="nd">#[structopt(short</span> <span class="nd">=</span> <span class="s">"k"</span><span class="nd">,</span> <span class="nd">long</span> <span class="nd">=</span> <span class="s">"keyfile"</span><span class="nd">,</span> <span class="nd">parse(from_os_str))]</span>
    <span class="n">keyfile</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="c">/// Check passwords against breached passwords online via the HaveIBeenPwned API. More info</span>
    <span class="c">/// here:</span>
    <span class="c">/// https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#cloudflareprivacyandkanonymity</span>
    <span class="nd">#[structopt(long</span> <span class="nd">=</span> <span class="s">"online"</span><span class="nd">)]</span>
    <span class="n">online</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="c">/// Provide password hash file to check database against. To download a copy of very large list of</span>
    <span class="c">/// password hashes from HaveIBeenPwned, go to: https://haveibeenpwned.com/Passwords</span>
    <span class="nd">#[structopt(short</span> <span class="nd">=</span> <span class="s">"h"</span><span class="nd">,</span> <span class="nd">long</span> <span class="nd">=</span> <span class="s">"hashfile"</span><span class="nd">,</span> <span class="nd">parse(from_os_str))]</span>
    <span class="n">hash_file</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="c">/// Check database for duplicate passwords</span>
    <span class="nd">#[structopt(short</span> <span class="nd">=</span> <span class="s">"d"</span><span class="nd">,</span> <span class="nd">long</span> <span class="nd">=</span> <span class="s">"duplicate"</span><span class="nd">)]</span>
    <span class="n">check_duplicate</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="c">/// Check database for weak passwords</span>
    <span class="nd">#[structopt(short</span> <span class="nd">=</span> <span class="s">"w"</span><span class="nd">,</span> <span class="nd">long</span> <span class="nd">=</span> <span class="s">"weak"</span><span class="nd">)]</span>
    <span class="n">check_weak</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="c">/// KeePass database to check. Can either be a kdbx file or an exported CSV version of a</span>
    <span class="c">/// KeePass database.</span>
    <span class="nd">#[structopt(name</span> <span class="nd">=</span> <span class="s">"KEEPASS DATABASE FILE"</span><span class="nd">,</span> <span class="nd">parse(from_os_str))]</span>
    <span class="n">keepass_db</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can access the values of these arguments by using <code class="language-plaintext highlighter-rouge">Opt::from_args()</code> like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// still in src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">opt</span> <span class="o">=</span> <span class="nn">Opt</span><span class="p">::</span><span class="nf">from_args</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Detected option(s):</span><span class="se">\n</span><span class="s">{:?}"</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>

    <span class="c">// and if we like, we can stash some of them in a fresh set of variables</span>
    <span class="k">let</span> <span class="n">keepass_db_file_path</span> <span class="o">=</span> <span class="n">opt</span><span class="py">.keepass_db</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hash_file</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">opt</span><span class="py">.hash_file</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">keyfile</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">opt</span><span class="py">.keyfile</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">check_online</span> <span class="o">=</span> <span class="n">opt</span><span class="py">.online</span><span class="p">;</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This solved two other problems for me: (1) It gave me a way to give the user an <em>optional</em> method of providing a keyfile. (Not every KeePass database requires a keyfile to open it.)</p>

<p>And (2), the file paths we ask the user for are already of type <code class="language-plaintext highlighter-rouge">PathBuf</code> rather than <code class="language-plaintext highlighter-rouge">String</code>s or string slices.</p>

<h2 id="replacing-a-bool-with-babys-first-enum">Replacing a <code class="language-plaintext highlighter-rouge">bool</code> with baby‚Äôs first <code class="language-plaintext highlighter-rouge">enum</code></h2>

<p>In previous versions of Medic, the function <code class="language-plaintext highlighter-rouge">check_database_offline</code> had a <code class="language-plaintext highlighter-rouge">bool</code> value for whether to display a progress bar or not. The primary reason for this was so I could turn it off for testing.</p>

<p>This worked fine, but it didn‚Äôt look great. For example, the actual, non-test call for the function looked like this</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">println!</span><span class="p">(</span><span class="s">"Checking KeePass database against provided hash file"</span><span class="p">);</span>
<span class="k">let</span> <span class="n">breached_entries</span> <span class="o">=</span> <span class="nf">check_database_offline</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<p>What‚Äôs that <code class="language-plaintext highlighter-rouge">true</code> doing hanging out there!? What‚Äôs set to <code class="language-plaintext highlighter-rouge">true</code>?</p>

<p>Luckily, I happened to stumble upon <a href="http://blakesmith.me/2019/05/07/rust-patterns-enums-instead-of-booleans.html">this wonderfully short blog post called ‚ÄúRust Patterns: Enums Instead of Booleans‚Äù</a>. As the title implies, the author advises that we can often be more descriptive  if we use <code class="language-plaintext highlighter-rouge">enum</code>s rather than <code class="language-plaintext highlighter-rouge">bool</code>eans.</p>

<p>With this lesson fresh in mind, I set about to refactor the ‚Äúprogress bar‚Äù bool into an enum (and rename it to <code class="language-plaintext highlighter-rouge">progress_bar_visibility</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">VisibilityPreference</span> <span class="p">{</span>
    <span class="n">Show</span><span class="p">,</span>
    <span class="n">Hide</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">check_database_offline</span><span class="p">(</span>
    <span class="n">passwords_file_path</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Entry</span><span class="p">],</span>
    <span class="n">progress_bar_visibility</span><span class="p">:</span> <span class="n">VisibilityPreference</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

        <span class="c">//...</span>

        <span class="k">let</span> <span class="n">pb</span> <span class="o">=</span> <span class="nn">ProgressBar</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">passwords_file_size</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">progress_bar_visibility</span> <span class="o">==</span> <span class="nn">VisibilityPreference</span><span class="p">::</span><span class="n">Show</span> <span class="p">{</span>
            <span class="n">pb</span><span class="nf">.set_style</span><span class="p">(</span>
                    <span class="nn">ProgressStyle</span><span class="p">::</span><span class="nf">default_bar</span><span class="p">()</span>
                    <span class="nf">.template</span><span class="p">(</span><span class="s">"{spinner} [{elapsed_precise}] [{bar:40}] ({eta})"</span><span class="p">),</span>
                    <span class="p">);</span>
        <span class="p">}</span>

        <span class="c">// ...</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now, calling the function looks much more descriptive:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// show progress bar in production</span>
<span class="k">let</span> <span class="n">breached_entries</span> <span class="o">=</span> <span class="nf">check_database_offline</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="nn">VisibilityPreference</span><span class="p">::</span><span class="n">Show</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

<span class="c">// hide progress bar for test functions</span>
<span class="k">let</span> <span class="n">breached_entries</span> <span class="o">=</span> <span class="nf">check_database_offline</span><span class="p">(</span><span class="n">passwords_file_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="nn">VisibilityPreference</span><span class="p">::</span><span class="n">Hide</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="attempting-to-detect-similar-passwords-using-zxcvbn">Attempting to detect similar passwords using zxcvbn</h2>

<p>While checking for repeated passwords is nice and potentially useful, I thought it‚Äôd be cool if the tool could also detect passwords that are <em>similar</em> as well, for example <code class="language-plaintext highlighter-rouge">Spot34</code> and <code class="language-plaintext highlighter-rouge">Spot43</code>. I <em>hoped</em> that I could use that feature of zxcvbn where it optionally takes related words to accomplish this: I‚Äôd just shove all the other passwords into that Vector and see if the password still got a high-enough score.</p>

<p>This worked OK if the differences in the passwords where capitalization, for example <code class="language-plaintext highlighter-rouge">Spot34</code> gets a lower score if you submit <code class="language-plaintext highlighter-rouge">spot34</code> as a related word. But sadly it seems not to do anything with numbers: <code class="language-plaintext highlighter-rouge">Spot34</code> doesn‚Äôt get a lower score if you submit <code class="language-plaintext highlighter-rouge">Spot43</code> along with it.</p>

<p>So, for now, I‚Äôve scrapped this feature. If you have any ideas on how to better implement it, let me know!</p>

<h2 id="learning-about-is_some">Learning about <code class="language-plaintext highlighter-rouge">is_some()</code></h2>

<p>A small Rust thing I learned: When I implemented the keyfile functionality mentioned above, I was sure to make <code class="language-plaintext highlighter-rouge">keyfile_path</code> an <code class="language-plaintext highlighter-rouge">Option</code>, specifically <code class="language-plaintext highlighter-rouge">Option&lt;&amp;str&gt;</code>, since not all KeePass databases are going to require key files to be unlocked.</p>

<p>At some point I need some control flow on whether this <code class="language-plaintext highlighter-rouge">keyfile_path</code> variable was present (a <code class="language-plaintext highlighter-rouge">Some</code>) or a <code class="language-plaintext highlighter-rouge">None</code>. My Ruby instincts told me I‚Äôd be able to just write <code class="language-plaintext highlighter-rouge">if keyfile_path</code> or <code class="language-plaintext highlighter-rouge">if Some(keyfile_path)</code> and, in that context, Rust would evaluate the variable as a Boolean. Of course Rust is too strict to allow this. But I did learn about <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some">the <code class="language-plaintext highlighter-rouge">is_some()</code> method</a>. Here‚Äôs how that would look with <code class="language-plaintext highlighter-rouge">keyfile_path</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">keyfile_path</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="c">// the database</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                 <span class="c">// password</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">keyfile_path</span><span class="nf">.unwrap</span><span class="p">()))</span><span class="nf">.unwrap</span><span class="p">()),</span> <span class="c">// keyfile</span>
            <span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Error opening database: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="c">// the database</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                 <span class="c">// password</span>
            <span class="nb">None</span><span class="p">,</span>                           <span class="c">// keyfile</span>
            <span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error opening database. Maybe you have a keyfile? If so, enter its file path:"</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">keyfile_path</span> <span class="o">=</span> <span class="nf">get_file_path</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nf">unlock_keepass_database</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">db_pass</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyfile_path</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The related, more elegant solution here is Rust‚Äôs <a href="https://doc.rust-lang.org/book/ch06-03-if-let.html"><code class="language-plaintext highlighter-rouge">if let</code></a>. This allows us to safely ‚Äúunwrap‚Äù the key file path variable without calling <code class="language-plaintext highlighter-rouge">unwrap()</code> (yay).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">unlock_keepass_database</span><span class="p">(</span>
        <span class="n">file_path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">db_pass</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">keyfile_path</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">keepass</span><span class="p">::</span><span class="n">Database</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">file_path</span><span class="p">);</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">keyf_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">keyfile_path</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="c">// the database</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                 <span class="c">// password</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">keyf_path</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">()),</span> <span class="c">// keyfile</span>
                <span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Error opening database: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="c">// the database</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                 <span class="c">// password</span>
                <span class="nb">None</span><span class="p">,</span>                           <span class="c">// keyfile</span>
                <span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error opening database. Maybe you have a keyfile? If so, enter its file path:"</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">keyfile_path</span> <span class="o">=</span> <span class="nf">get_file_path</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nf">unlock_keepass_database</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">db_pass</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyfile_path</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="calling-map-on-an-option">Calling <code class="language-plaintext highlighter-rouge">map</code> on an <code class="language-plaintext highlighter-rouge">Option</code></h2>

<p>Thanks to a <a href="http://disq.us/p/1zwjgam">comment on this post</a> by Frederic Dumont (thanks!), I learned that I could refactor this <code class="language-plaintext highlighter-rouge">unlock_keepass_database</code> a bit further. To be honest, I‚Äôm not super sure how this works, but clearly the two calls to <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code class="language-plaintext highlighter-rouge">map</code> on <code class="language-plaintext highlighter-rouge">Option</code></a>s do some solid work, which works on <code class="language-plaintext highlighter-rouge">keyfile</code> whether it‚Äôs a <code class="language-plaintext highlighter-rouge">None</code> or <code class="language-plaintext highlighter-rouge">Some</code>. We‚Äôre also introducing a call to <a href="https://rust-lang-nursery.github.io/edition-guide/rust-2018/trait-system/dyn-trait-for-trait-objects.html"><code class="language-plaintext highlighter-rouge">dyn</code></a>, which is some sort of way to use a trait object.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">unlock_keepass_database</span><span class="p">(</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
        <span class="n">db_pass</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">keyfile_path</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">keepass</span><span class="p">::</span><span class="n">Database</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">keyfile</span> <span class="o">=</span> <span class="n">keyfile_path</span><span class="nf">.map</span><span class="p">(|</span><span class="n">kfp</span><span class="p">|</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">kfp</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>

    <span class="k">match</span> <span class="nn">Database</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span>               <span class="c">// the database</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_pass</span><span class="p">),</span>                               <span class="c">// password</span>
            <span class="n">keyfile</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">f</span><span class="p">|</span> <span class="n">f</span> <span class="k">as</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">dyn</span> <span class="n">Read</span><span class="p">),</span> <span class="c">// keyfile</span>
            <span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">db</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error opening database: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So I don‚Äôt love introducing multiple lines that I don‚Äôt understand well, but this version is so much more concise I decided to implement it.</p>

<h2 id="epilogue-collections-2-through-5">Epilogue: Collections #2 through #5</h2>

<p>On January 31, 2019, Collections #2 through #5 dropped. <a href="https://www.wired.co.uk/article/collection-data-breach-dump-leak">Wired reports</a>:</p>

<blockquote>
  <p>The new Collection leak, which was first reported by Heise, contains 2.2 billion unique usernames and passwords. In total it contains 845GB of data and more than 25bn records.</p>
</blockquote>

<p>I‚Äôm not sure how to get my hands on this dump, but I‚Äôd be curious to see how Medic performs with such a long list. Maybe a few hours? Could be good inspiration to squeeze more efficiency out of the offline check function, and/or implement threading‚Ä¶</p>
:ET