I"x1<p>If you’re like me you’ve got a lot of <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm">time-based one-time passwords</a> (aka “TOTP”) in a smartphone app like Google Authenticator. This system works pretty well: The service presents you with a QR code, you scan it with Google Authenticator, and then every 30 seconds you get a fresh 6-digit code to use as your second factor when logging in to the service. It’s more secure than using SMS for reasons I won’t spell out here.</p>

<p>As you might have intuited, this QR code contains a secret code – a string of random alphanumeric characters unique to your account. Google Authenticator stores this secret code, but doesn’t allow the user to read them (I assume for security reasons). Google Authenticator then uses <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm#Algorithm">an algorithm</a> to mix the secret with the current time and generate a new 6-digit code every 30 seconds. Thus we can think of these secret codes as “seeds”, but for the remainder of this post I’ll refer to them as “secrets” or “text secrets”.</p>

<p>If you indeed use Google Authenticator to store and display these codes, you should know that Google Authenticator does NOT offer a method for backing up the stored secrets. (<a href="https://authy.com/">Authy</a> does offer back-ups, but they live on their servers.)</p>

<p>So what if you lose or break your phone? Well, that’s what the “back-up codes” that the service gives you are for. Store them somewhere secure, and then when you break/lose your phone, use one of the back-up codes instead of the 6-digit code.</p>

<p>But I’ve found some services either give you only one back-up code, and reset it every time you ask to view it (Twitter), or don’t even give you any back-up codes at all (ConEdison). In these cases, I think I’d like a way to store the QR codes, or better yet: store the actual TOTP secrets (the random text strings) and make QR codes as needed.</p>

<h2 id="but-isnt-this-less-secure-than-not-retrieving-and-storing-the-secrets">But Isn’t This Less Secure Than Not Retrieving and Storing the Secrets?</h2>

<p>Short answer: yeah, it can make your system less secure. But my logic is that if I store these secrets in the same location and/or with the same care and procedure as I store back-up codes, I’m not really losing much security.</p>

<p>I will say you probably do NOT want to store these secrets in the same KeePass database as your account passwords.</p>

<h2 id="my-goal">My Goal</h2>

<p>I wanted to create a reliable procedure to extract these secrets from a given QR code, and store these secrets somewhere off of my phone. (Note: this is distinct from storing the <em>back-up codes</em>, which I was already doing). My hope is to make my inevitable transition from a lost or destroyed phone to a new phone as easy as possible. (Though if my phone was stolen, I’d probably want to fully reset all of my TOTPs just to be safe…)</p>

<p>To accomplish this, I could have simply screenshotted the QR codes when they’re presented to me and store the image files securely, ready to be rescanned on my new phone. However I wanted to instead store the secrets themselves (a string of random characters) for two reasons: (1) my password manager of choice, <a href="https://keepassxc.org/">KeePassXC</a>, <a href="https://keepassxc.org/docs/#faq-security-totp">can store these secrets and present TOTPs on command</a>, but you have to input the secret as text, as opposed to a QR code, and (2) I was curious how the QR codes worked.</p>

<h2 id="a-bit-more-about-qr-codes">A Bit More About QR Codes</h2>

<p><a href="https://en.wikipedia.org/wiki/QR_code#URLs">One of the things that a Quick Response code (QR code) can contain is a URL</a> or URI (<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier</a>). The QR codes we’re dealing with here contain an otpauth URI, which look like <code class="language-plaintext highlighter-rouge">otpauth://totp/hereisthelabel?secret=hereisthesecret&amp;issuer=hereistheissuer</code>. This particular URI format is <a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format">defined further</a> in the Google Authenticator GitHub repo. The <code class="language-plaintext highlighter-rouge">secret</code> parameter is the most important for us, but we’ll use the label and issuer too.</p>

<p>There are a few online tools to make your own QR codes containing otpauth URIs: I found <a href="https://authenticator.ppl.family/">Authenticator Test</a> and <a href="https://stefansundin.github.io/2fa-qr/">2FA QR code generator</a>. I would NOT recommend entering your actual account secrets into these online generators cuz they are on the internet. However you can use them to test my procedure I outline below if you don’t want to use your real account secrets.</p>

<h2 id="the-system-i-ended-up-with">The System I Ended Up With</h2>

<p>I ended up installing two separate command line tools to accomplish my goal, one to convert screenshots of QR code into their base URIs, and another to take URIs and create new QR codes. If you’re not comfortable using the command line, sorry, this procedure is going to be hard for you. However there may be GUI options for this for your OS.</p>

<h2 id="setup">Setup</h2>

<h3 id="macos">MacOS</h3>

<ol>
  <li>Install <a href="https://brew.sh/">Homebrew</a></li>
  <li>Run <code class="language-plaintext highlighter-rouge">brew install zbar qrencode</code></li>
</ol>

<h3 id="ubuntu-based-linux">Ubuntu-based Linux</h3>
<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">sudo apt install zbar-tools qrencode</code></li>
</ol>

<h2 id="steps-for-accessing-totp-secret-for-twitter-qr-code-to-text-secret">Steps For Accessing TOTP Secret for Twitter (QR Code to Text Secret)</h2>

<p>As mentioned above, I dislike Twitter’s handling of back-up codes. First, because Twitter only gives me one back-up code (as opposed to 8 or 10 like other services), but also because it’s my understanding that every time I ask to view the back-up code, it gives me a new one, implying that the previous back-up codes will no longer work.</p>

<p>So I went about getting a new QR code from Twitter, getting the secret out of the QR code and finally storing it in a KeePass database using <a href="https://keepassxc.org/">KeePassXC</a>.</p>

<p>Here are the steps I took to do this.</p>

<p>If you already have any login verification setup, you’ll need to turn it off first then turn it back on. Note: To turn it back on via any method, you’ll need to receive an SMS message to your set phone number.</p>

<p>Once you do this, you’ll get a new back up code – store it some place safe.</p>

<ol>
  <li>(Re)Setup “Mobile security app” (aka TOTP) 2nd factor for your Twitter account.</li>
  <li>Take a screenshot of the QR code  you’re presented with. Save it to your desktop.</li>
  <li>Add this QR code to your Google Authenticator just in case the rest of this procedure fails.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">zbarimg --raw &lt;path to screenshot&gt;</code>. The output should contain a otpauth URI; something like <code class="language-plaintext highlighter-rouge">otpauth://totp/Twitter?secret=hereisthesecret&amp;issuer=Twitter</code>. We’ll be using the “secret” soon.</li>
  <li>Now either write down this secret, next to “Twitter” and your username, and store it somewhere safe and away from your password – wherever you store your back-up codes for example. (Alternatively you can store the secret in a KeePass database. To do this, create a new entry in a KeePass database called “Twitter TOTP code”. Right-click the entry and select “Setup TOTP”. In the “Key” text field, enter the secret from the URI we got before from the <code class="language-plaintext highlighter-rouge">zbarimg</code> command. Select the radio button for “Default RFC 6238 token settings”. Click “OK”.)</li>
  <li>As a test, let’s generate a fresh QR code from this secret/key. Run <code class="language-plaintext highlighter-rouge">qrencode -s 10 -o ~/Pictures/generated_qr_code.png 'otpauth://totp/Twitter:@twitter_username?secret=hereisthesecret&amp;issuer=Twitter'</code></li>
  <li>Open <code class="language-plaintext highlighter-rouge">~/Pictures/generated_twitter_qr_code.png</code> on your computer. You should see a QR code! Next open Google Authenticator on your phone and point it at the newly generated QR code.</li>
  <li>Compare the two 6-digit codes in Google Authenticator – they should be the same! If they are the same, feel free to remove one of them from your Google Authenticator app.</li>
</ol>

<h3 id="moderately-secure-clean-up-on-linux">Moderately Secure Clean Up on Linux</h3>

<p>On Linux:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">shred</span> <span class="nt">-ufv</span> <span class="nt">--iterations</span><span class="o">=</span>20 ~/Pictures/generated_qr_code.png
<span class="nb">shred</span> <span class="nt">-ufv</span> <span class="nt">--iterations</span><span class="o">=</span>20 ~/Pictures/&lt;original screenshot of QR code&gt;
</code></pre></div></div>

<p>Then open <code class="language-plaintext highlighter-rouge">~/.bash_history</code> in your text editor of choice and delete the lines the contain your secret. This isn’t a perfect way to cover your tracks, but it doesn’t hurt.</p>

<h3 id="notes-on-other-methods-of-twitter-login-verification">Notes on Other Methods of Twitter Login Verification</h3>

<p>The above procedure will leave SMS (text message) login verification <strong>enabled</strong>. If you don’t want this enabled (for example if you’re afraid of <a href="https://motherboard.vice.com/en_us/article/zm8a9y/how-to-protect-yourself-from-sim-swapping-hacks">a SIM-swapping attack</a>), you’ll have to disable it yourself.</p>

<p>Also, if you had enabled a security key (like a <a href="https://www.yubico.com/">YubiKey</a>) for Twitter login verification, you’ll need to set that up again. (Here’s <a href="https://motherboard.vice.com/en_us/article/bj3qxw/how-to-twitter-account-yubikey-guide">a guide from Vice</a>.)</p>

<h2 id="using-a-secret-to-create-a-qr-code-text-secret-to-qr-code">Using a Secret to Create a QR Code (Text Secret to QR Code)</h2>

<p>Now we have the secret stored securely. So let’s say we want to use this secret to make a QR code to scan with our new phone.</p>

<p>For my Twitter account (@sts10), I’d run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qrencode <span class="nt">-s</span> 10 <span class="nt">-o</span> generated_twitter_qr_code.png <span class="s1">'otpauth://totp/Twitter:@sts10?secret=hereismysecret&amp;issuer=Twitter'</span>
</code></pre></div></div>

<p>Alternatively, Google Authenticator has an option to manually enter an account name and its key (secret).</p>

<p>To get your secret out of a KeePassXC entry, Edit the entry &gt; Click the Advanced icon &gt; Highlight “TOTP Seed” under Additional Attributes &gt; click the “Reveal” button on the right.</p>

<h2 id="a-keepassxc-feature-request">A KeePassXC Feature Request</h2>

<p>It’d be super handy if users of KeePassXC could simply <em>drag</em> a screenshot (or image) of a QR code containing a otpauth URI and drop it into a KeePass database entry to setup TOTP in one go. Likewise, it’d be nice if, once users set up TOTP for a given entry, KeePassXC had an option to show or create the corresponding for QR code.</p>

<h2 id="appendix">Appendix</h2>

<p>Here’s <a href="https://github.com/shello/2fa_scripts">a shell script that takes an otpauth URI and presents the current 6-digit code</a>, among other things (<a href="https://octodon.social/@shello/101099361987648303">h/t @shello@octodon.social</a>).</p>

<h2 id="epilogue-2020">Epilogue (2020)</h2>

<p>As of summer 2020, KeePassXC v 2.6.0+ can create QR codes from TOTP secret keys, all while storing everything in an encrypted database. This is almost certainly a safer choice than using qrencode.</p>

<p>To read a TOTP secret key(s) from a given QR code image file, zbar still seems like a fine solution.</p>

<p>I’ll also note here that, since writing this post, I created a command-line tool called <a href="https://github.com/sts10/qr-forge">QRForge</a> that can transfer between both formats relatively safely.</p>
:ET