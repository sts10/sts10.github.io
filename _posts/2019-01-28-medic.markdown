---
layout: post
title: "Medic: A Rust CLI that checks the passwords of a KeePass database"
date: 2019-01-31 21:15:00 -0400
comments: true
---

Midway through January 2019 news broke of a large cache of emails and passwords, dubbed ["Collection #1"](https://www.troyhunt.com/the-773-million-record-collection-1-data-reach/), surfacing on the internet. Troy Hunt writes that it includes 772,904,991 unique email addresses and 21,222,975 unique passwords. Wow! Hunt cleaned and loaded the data into his service called HaveIBeenPwned, which allows (non-technical) users to enter either their [email](https://haveibeenpwned.com/) or [password(s)](https://haveibeenpwned.com/Passwords) to see if their data was included in the breach (or earlier breaches that he's cataloged). Hunt's total list of passwords now includes more than half a billion unique passwords.

While I'm reasonably OK entering my email address into the HaveIBeenPwned website, I was a bit more skeptical about entering any of my passwords. Hunt employs something called [k-anonymity](https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#cloudflareprivacyandkanonymity) to make the password search safer. You can check your passwords this way either by manually entering it in [a webpage](https://haveibeenpwned.com/Passwords), or via [a lovely little API](https://haveibeenpwned.com/API/v2). If using the API, users only need to send the first 5 characters of the SHA-1 hash of their password over the internet. The API then returns all the hashes that have that 5-character prefix, and the user does the rest of the work. I copied most of this code from [David Hewitt's Password Check](https://github.com/davidhewitt/password-check).

Additionally, Hunt makes the (very large) text file of current, half-billion password list [available to the general public for download](https://haveibeenpwned.com/Passwords), either as a torrent or hosted by Cloudflare. After the recent breach, I was curious to check my passwords against the list, but I'm a bit paranoid, so I wanted to download the big text file and check my passwords against it offline, nice and safely. 

```text
7C4A8D09CA3762AF61E59520943DC26494F8941B:23174662
F7C3BC1D808E04732ADF679965CCC34CA7AE3441:7671364
B1B3773A05C0ED0176787A4F1574FF0075F7521E:3810555
5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8:3645804
3D4F2BF07DC1BE38B20CD6E46949A1071F9D0E3D:3093220
7C222FB2927D828AF22F592134E8932480637C0D:2889079
6367C48DD193D56EA7B0BAAD25B19455E529F5EE:2834058
20EABE5D64B0E216796E834F52D61FD0B70332FC:2484157
E38AD214943DAAD1D64C102FAEC29DE4AFE9DA3D:2401761
8CB2237D0679CA88DB6464EAC60DA96345513964:2333232
```

I use a password manager called KeePassXC, so all of my passwords are stored in an encrypted file -- a KeePass database -- and I use a program called [KeePassXC](https://keepassxc.org/), a free and open-source password manager, to manage them (I wrote [a beginner's user guide to KeePassXC](https://sts10.github.io/2017/06/27/keepassxc-setup-guide.html) a while back if you're interested!). So ideally, to check my passwords against the big list, I'd have a tool that checks all the passwords in a given KeePass database against the entire HaveIBeenPwned list of passwords, preferably against the downloaded file (i.e. "offline"), rather than the API. After poking around a bit I decided to write it myself in Rust, with [this script](https://github.com/davidhewitt/password-check/blob/master/src/main.rs) and [this crate](https://github.com/sseemayer/keepass-rs) as useful references.

## What I wrote

[Medic](https://github.com/sts10/medic) is a Rust CLI that can perform a variety of "health" checks on a KeePass database. It works! But I'm going to give a big ol' "buyer beware" on it -- I am a social media producer by trade, and have never written software so close to sensitive data before. (Of course, part of the promise of Rust is that it enables more people to write "safe" code, so this was a natural challenge for me.)

Please refer to the [ReadMe](https://github.com/sts10/medic/blob/master/readme.markdown) for setup and usage instructions. In this post I'm going to go over some of my Rust code and what it does.

I have run my personal KeePass database through the program (actually I exported my database to a CSV and ran that through the program -- [I outline the steps I actually took in the README](https://github.com/sts10/medic#how-i-chose-to-use-this-tool)). It found a few old passwords (that I was still using) among the HIBP list, though I should note that none of the passwords I used KeePassXC or 1Password to randomly generated were on the breach list. There is an open question of the usefulness of this kind of check -- the logci of the question si something like "Wouldn't a KeePass user not have any common passwords, thus a check against a breach list like this be pointless?" My tentative answer is that even the strongest of passwords can be exposed. Sure, it may only appear on the list once, but it's still there and a tool like Medic is one of the safer yet moderately efficient ways I can think of to learn if that's true or not for any of your passwords.

## Reading a KeePassXC database

With the [keepass-rs crate](https://github.com/sseemayer/keepass-rs) loaded up, unlocking and reading the entries of KeePass database was pretty easy. Below is an early version of a function that did just that: 

```rust
fn get_entries_from_keepass_db(file_path: &str) -> Vec<Entry> {
    let mut entries: Vec<Entry> = vec![];

    let db_pass =
        rpassword::read_password_from_tty(Some("Enter the password to your KeePass database: "))
        .unwrap();
    // Open KeePass database
    println!("Attempting to unlock your KeePass database...");
    let db = match File::open(std::path::Path::new(file_path))
        .map_err(OpenDBError::Io)
        .and_then(|mut db_file| Database::open(&mut db_file, &db_pass))
        {
            Ok(db) => db,
                Err(e) => panic!("Error: {}", e),
        };

    println!("Reading your KeePass database...");
    // Iterate over all Nodes
    for node in &db.root {
        match node {
            Node::Entry(e) => {
                let this_entry = Entry {
                    title: e.get_title().unwrap().to_string(),
                    username: e.get_username().unwrap().to_string(),
                    pass: e.get_password().unwrap().to_string(),
                    digest: sha1::Sha1::from(e.get_password().unwrap().to_string())
                       .digest()
                       .to_string()
                       .to_uppercase(),
                };
                entries.push(this_entry);
            }
        }
    }
    entries
}
```

I read this data into a Vector of Entries, which is a Rust `struct` I defined like this: 

```rust
#[derive(Debug, Clone)]
pub struct Entry {
    title: String,
    url: String,
    username: String,
    pass: String,
    digest: String,
}
```

### How I read in a KeePass database in the current version of Medic

As I wrote more code and added more features to the program -- including taking a keyfile or a CSV export of the user's database, I broke the "Read KeePass database entries into Vector of Structs" task into a couple of functions, all located in `src/lib.rs`

```rust
pub fn get_entries(file_path: &str, keyfile_path: Option<&str>) -> Vec<Entry> {
    let file_extension = get_file_extension(file_path);

    let db_pass: Option<String> = if file_extension != "csv" {
        Some(
                rpassword::read_password_from_tty(Some(
                        "Enter the password to your KeePass database: ",
                        ))
                .unwrap(),
            )
    } else {
        None
    };

    if file_extension != "csv" && db_pass.is_some() {
        build_entries_from_keepass_db(file_path, db_pass.unwrap(), keyfile_path)
    } else {
        build_entries_from_csv(file_path)
    }
}

fn build_entries_from_keepass_db(
        file_path: &str,
        db_pass: String,
        keyfile_path: Option<&str>,
        ) -> Vec<Entry> {
    let mut entries: Vec<Entry> = vec![];

    println!("Attempting to unlock your KeePass database...");
    let db = unlock_keepass_database(file_path, db_pass, keyfile_path);
    // Iterate over all Groups and Nodes
    for node in &db.root {
        match node {
            Node::GroupNode(_g) => {
                // println!("Saw group '{}'", g.name);
            }
            Node::EntryNode(e) => {
                let this_entry = Entry {
title: e.get_title().unwrap().to_string(),
           username: e.get_username().unwrap().to_string(),
           url: e.get("URL").unwrap().to_string(),
           pass: e.get_password().unwrap().to_string(),
           digest: sha1::Sha1::from(e.get_password().unwrap().to_string())
               .digest()
               .to_string()
               .to_uppercase(),
                };
                if this_entry.pass != "" {
                    entries.push(this_entry);
                }
            }
        }
    }
    println!("Successfully read KeePass database!");
    entries
}

// helper function that does the actual unlocking
fn unlock_keepass_database(
        file_path: &str,
        db_pass: String,
        keyfile_path: Option<&str>,
        ) -> keepass::Database {
    let path = std::path::Path::new(file_path);

    if keyfile_path.is_some() {
        match Database::open(
                &mut File::open(path).unwrap(), // the database
                Some(&db_pass),                 // password
                Some(&mut File::open(std::path::Path::new(keyfile_path.unwrap())).unwrap()), // keyfile
                ) {
            Ok(db) => db,
            Err(e) => panic!("Error opening database: {}", e),
        }
    } else {
        match Database::open(
                &mut File::open(path).unwrap(), // the database
                Some(&db_pass),                 // password
                None,                           // keyfile
                ) {
            Ok(db) => db,
            Err(_e) => {
                println!("\nError opening database. Maybe you have a keyfile? If so, enter its file path:");
                let keyfile_path = get_file_path().unwrap();
                unlock_keepass_database(file_path, db_pass, Some(&keyfile_path))
            }
        }
    }
}
```

When I started this project the keepass-rs crate wasn't able to unlock KeePass databases that were locked with keyfiles. Feeling lucky, I opened [an issue](https://github.com/sseemayer/keepass-rs/issues/8) on the crate's GitHub repo and just hours later the maintainer responded. The next day he wrote the feature into the crate, and I bumped it version `0.3.1`. Open source ftw! 

Now I made an interesting UI choice here -- I decided to only prompt for a keyfile location if the user entering his or her password fails to decrypt the database (see the bottom part of `fn unlock_keepass_database`). This isn't _great_, since the user might have simply typed their master password incorrectly. If that happens they're going to be in for a bad time, cuz the program immediately prompts them for a keyfile, something they might not even know about. If anyone has a better way for the user to easily indicate that their database requires a keyfile, let me know in the comments!

## Using the HaveIBeenPwned API to offer users an online check

You're welcome to checkout the code to the API/"online" check, but again, I mostly copied it from [this very clean project](https://github.com/davidhewitt/password-check). Hope that's cool, David!

## The offline check: Splitting the work into chunks

Once I successfully downloaded the 11 GB file of passwords and extracted it to a usable `txt` file (22.6 GB), I was able to begin work on the offline check. 

Here are the first 10 lines: 

```text
7C4A8D09CA3762AF61E59520943DC26494F8941B:23174662
F7C3BC1D808E04732ADF679965CCC34CA7AE3441:7671364
B1B3773A05C0ED0176787A4F1574FF0075F7521E:3810555
5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8:3645804
3D4F2BF07DC1BE38B20CD6E46949A1071F9D0E3D:3093220
7C222FB2927D828AF22F592134E8932480637C0D:2889079
6367C48DD193D56EA7B0BAAD25B19455E529F5EE:2834058
20EABE5D64B0E216796E834F52D61FD0B70332FC:2484157
E38AD214943DAAD1D64C102FAEC29DE4AFE9DA3D:2401761
8CB2237D0679CA88DB6464EAC60DA96345513964:2333232
```

The format is `<SHA-1 hash of the password>` ([what's a SHA-1 hash?](https://en.wikipedia.org/wiki/SHA-1))and then a colon, then the number of times that particular password appeared in the various breaches (a number I didn't have much interest in). The last 10 lines are very similar, but all of the number-of-appearances are `1`.

So, to review, our task is to open up a KeePass database (see above), make SHA-1 hashes (digests) of all the passwords (I do this when I build the `Entry` objects), then see if they appear in this 550-million-line text document. 

My first problem: figuring out how to read this massive amount of data in to my Rust program in order to work with it.

In my first attempt, I brazenly [tried to read all 550 million hashes into a single, massive Vector](https://github.com/sts10/medic/blob/1770df4d4f5383768c466847c669e95f3e0451fd/src/main.rs#L197). 

```rust
fn read_by_line(file_path: &str) -> io::Result<Vec<String>> {
    let mut vec = Vec::new();
    let f = match File::open(file_path.trim_matches(|c| c == '\'' || c == ' ')) {
        Ok(res) => res,
            Err(e) => return Err(e),
    };
    let file = BufReader::new(&f);
    let mut line_number = 0;
    for line in file.lines() {
        line_number = line_number + 1;
        println!("Reading line #{:?}", line_number);
        vec.push(line.unwrap());
    }
    Ok(vec)
}
```

As you might guess, this slowly but surely tried to fill up 22.6 GB of my RAM. (While I have 32 GB on this machine (rah!), this obviously wasn't a viable method.)

I had a few ideas of how to solve this issue, but [a Fediverse friend](https://fosstodon.org/@codesections/101463247584610406) helped me decide to split the data into chunks. After some testing I did later, I found that 10 million lines per chunk was a pretty good size.

```rust
fn check_database_offline(passwords_file_path: &str, entries: Vec<Entry>) -> io::Result<Vec<Entry>> {
  let mut this_chunk = Vec::new();
  let mut breached_entries: Vec<Entry> = Vec::new();

  let f = match File::open(passwords_file_path) {
    Ok(res) => res,
      Err(e) => return Err(e),
  };

  // times via `cargo test --release can_check_offline --no-run && time cargo test --release can_check_offline -- --nocapture`
  // let chunk_size = 1_000_000; // real 1m24.709s
  // let chunk_size = 20_000_000; // real 1m13.159s
  let chunk_size = 10_000_000; // real 1m14.613s

  let file = BufReader::new(&f);
  for line in file.lines() {
    this_chunk.push(line.unwrap());
    if this_chunk.len() > chunk_size {
      match check_this_chunk(&entries, &this_chunk) {
        Ok(mut vec_of_breached_entries) => {
          breached_entries.append(&mut vec_of_breached_entries)
        }
        Err(_e) => eprintln!("found no breached entries in this chunk"),
      }
      this_chunk.clear();
    }
  }
  Ok(breached_entries)
}
```

The `for line in files.lines()` loop loops through each line of the file. When the `len` of the chunk gets larger than the designated `chunk_size`, it dips into that `match` statement, which sends `this_chunk`, as well as a reference to the users `entries`, to another function called `check_this_chunk`. If `check_this_chunk` finds any passwords from your KeePass entries in that chunk, it returns them in a `Result`, then `append`s them to a Vector called `breached_entries` (if no matches, does nothing). Next, _crucially_ it `clear`s `this_chunk` before continuing through the big file. 

Then it moves on to building the next chunk.

The result is that we never have more than 10 million password hashes stores in RAM at one time. 

This works pretty well! Running rustc in release mode, it takes about 70 seconds to check a test KeePass database of 5 or so entries. To check my ~80-entry database, it was more like 2 minutes. Not terrible! 

## Doing the checking

Once I got this chunk thing figured out, doing the actual hash digest comparisons was relatively easier -- nested `for` loops.

```rust
fn check_this_chunk(entries: &[Entry], chunk: &[String]) -> io::Result<Vec<Entry>> {
    let mut breached_entries = Vec::new();

    for line in chunk {
        let this_hash = &line[..40];

        for entry in entries {
            if this_hash == entry.digest {
                breached_entries.push(entry.clone());
            }
        }
    }
    Ok(breached_entries)
}
```

I made it a little easier on myself here and used `clone()` so that I wouldn't have to worry as much about ownership. I figured this was OK resource-wise, since (hopefully) no one's going to have thousands or even hundreds of breached entries in a single KeePass database.

I did experiment a little with [Rust's `HashSet`](https://doc.rust-lang.org/std/collections/struct.HashSet.html) collection type, in an effort to speed up this check, but -- the way I implemented them at least -- it wasn't noticeably faster. Could be a good future project though, along with adding threading.

### Adding a progress bar and learning that line counting is pretty slow?! 

While this offline check worked reasonably well, it still took 1 to 3 minutes to complete. While, in [my previous experience](https://sts10.github.io/2018/12/07/optimizing-rust-advent-of-code-day-5.html), if you work hard enough you can speed Rust up significantly, I thought that before banging my head on that it'd be fun to see if I could implement a progress bar. I found two crates for just this: [pb](https://github.com/a8m/pb) and [indicatif](https://github.com/mitsuhiko/indicatif). I found indicatif's API a little more sensible, and it allowed for colors, so I went with that (though pb seems more lightweight).

I hit a sticking point here though: both progress bar libraries require you to set some value for when the progress bar should be done. For example, if you're cranking through 550M lines, you might want to set this value to `550_000_000`, and you'd call `pb.inc(chunk_size as u64)` each time you finished checking a chunk. Obviously hardcoding the `550_000_000` is one option here, but it's not ideal -- what if the file HaveIBeenPwned offers gets larger over time? 

So I tried having Rust count the lines of the inputed file -- something like `f.lines().unwrap().len()` -- but this turned to take a real long time for a 550-million line text file -- like a minute at least. Since I was only doing this for the progress bar, that was unacceptable. But rather than ditch the progress bar or resort to hard-coding a value, I ended up using `f.metadata.unwrap().len()` to get the _number of bytes_ of the file. This call is much quicker, which kind of makes sense intuitively? 

My next problem was estimated the size of each chunk in bytes rather than line numbers. 500 MB felt like a good RAM requirement for the user -- I felt OK hard-coding that value. But now I had to figure out how to check the byte size of a Rust Vector as I added to it.

I kind of forget how I did this -- maybe [`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) -- but by my first measure I found that one line of the text file was 24 bytes. But when I tried using this value, the progress bar would get to 50% and the process would end, so I just doubled it to `48` and went with that. Again, if you have a more scientific way of correctly

```rust
pub fn check_database_offline(
        passwords_file_path: &str,
        entries: Vec<Entry>,
        progress_bar: bool,
        ) -> io::Result<Vec<Entry>> {
    let mut this_chunk = Vec::new();
    let mut breached_entries: Vec<Entry> = Vec::new();

    let f = match File::open(passwords_file_path) {
        Ok(res) => res,
            Err(e) => return Err(e),
    };
    let passwords_file_size = f.metadata().unwrap().len() as usize;

    // times via `cargo test --release can_check_offline --no-run && time cargo test --release can_check_offline -- --nocapture`
    // let chunk_size = 1_000_000_000; // real 1m6.354s
    let chunk_size = 500_000_000; // real 1m7.686s

    let pb = ProgressBar::new(passwords_file_size as u64);
    if progress_bar {
        pb.set_style(
                ProgressStyle::default_bar()
                .template("{spinner} [{elapsed_precise}] [{bar:40}] ({eta})"),
                // .progress_chars("#>-"),
                );
    }

    let file = BufReader::new(&f);
    for line in file.lines() {
        let this_line = line.unwrap()[..40].to_string();
        this_chunk.push(this_line);
        if this_chunk.len() * 48 > chunk_size {
            match check_this_chunk(&entries, &this_chunk) {
                Ok(mut vec_of_breached_entries) => {
                    breached_entries.append(&mut vec_of_breached_entries)
                }
                Err(_e) => eprintln!("found no breached entries in this chunk"),
            }
            if progress_bar {
                pb.inc(chunk_size as u64);
            }
            this_chunk.clear();
        }
    }
    if progress_bar {
        pb.finish_with_message("Done.");
    }
    Ok(breached_entries)
}

```

## Checking for weak passwords with zxcvbn

Next, since I had already done all the work to read in a user's passwords, I figured I might as well build out an option to check their database for _weak_ passwords. 

Troy Hunt actually [suggests doing this in his original blog post about the password list](https://www.troyhunt.com/introducing-306-million-freely-downloadable-pwned-passwords/) in conjunction with a HaveIBeenPwned check -- he recommends using [zxcvbn](https://github.com/dropbox/zxcvbn), a "low-budget password strength checker" from Dropbox. 

Luckily, a few months ago I used Rust to make [this little password checker](https://github.com/sts10/password-strength-checker) that uses [a Rust port of zxcvbn](https://github.com/shssoichiro/zxcvbn-rs). The Rust port is pretty straight-forward to use. Here are the two functions I needed:

```rust
pub fn check_for_and_display_weak_passwords(entries: &[Entry]) {
    for entry in entries {
        let estimate = zxcvbn(&entry.pass, &[&entry.title, &entry.username]).unwrap();
        // estimate.score gives is a 0 to 4 score of the password
        if estimate.score < 4 {
            println!("Your password for {} is weak.", entry);
            give_feedback(estimate.feedback);
            println!("\n--------------------------------");
        }
    }
}

fn give_feedback(feedback: Option<zxcvbn::feedback::Feedback>) {
    match feedback {
        Some(feedback) => {
            if let Some(warning) = feedback.warning {
                println!("Warning: {}\n", warning);
            }
            println!("Suggestions:");
            for suggestion in feedback.suggestions {
                println!("   - {}", suggestion)
            }
        }
        None => println!("No suggestions."),
    }
}
```

Two cool things here: First, that second argument to `zxcvbn` is a Vector of related words, like username or service title, to assist zxcvbn in estimating the password's strength. For example, `github_rocks123` might be an OK password for Tumblr, but it's a worse choice for GitHub.

Second, the  function returns "feedback", which I wrote a helper function to display. Examples of feedback are like, "Don't use dates".

## Using a HashMap to find and organize duplicate passwords 

Next, I figured I'd offer the option of finding re-used or duplicate passwords. To do this, I used a Rust HashMap and this neat `entry`/`and_modify`/`or_insert` pattern [I've used before](https://sts10.github.io/2018/12/02/lessons-from-first-two-days-of-advent-of-code-2018.html#7-the-entry--and_modify--or_insert-pattern-for-hashmaps) that's great for counting things. 

To be a _little_ safer, I decided to use the password hash digests for the keys of the HashMap. The values are a Vector of all the entries whose password digest is the same. So if none of your KeePass databases entries share passwords, all of the keys of this HashMap will only have one Entry in their attached Vectors. But if, say, three entries share a password, the digest of that password will be a key and it's value will be a Vector with 3 Entries in it.

```rust
pub fn make_digest_map(entries: &[Entry]) -> io::Result<HashMap<String, Vec<Entry>>> {
    let mut digest_map: HashMap<String, Vec<Entry>> = HashMap::new();
    for entry in entries {
        digest_map
            .entry(entry.clone().digest)
            .and_modify(|vec| vec.push(entry.clone()))
            .or_insert_with(|| vec![entry.clone()]);
    }

    Ok(digest_map)
}

// Clippy told me "warning: parameter of type `HashMap` should be generalized over different hashers"
pub fn present_duplicated_entries<S: ::std::hash::BuildHasher>(
        digest_map: HashMap<String, Vec<Entry>, S>,
        ) {
    let mut has_duplicated_entries = false;
    for groups in digest_map.values() {
        if groups.len() > 1 {
            println!("The following entries have the same password:\n");
            for entry in groups {
                println!("   - {}", entry);
            }
            has_duplicated_entries = true;
        }
    }

    if has_duplicated_entries {
        println!("\nPassword re-use is bad. Change passwords until you have no duplicates.");
    } else {
        println!("\nGood job -- no password reuse detected!");
    }
}
```

Gonna be straight with you: I'm not 100% sure about that `.or_insert_with(|| vec![entry.clone()]);` line -- it was a Clippy suggestion. I had a simple `or_insert` call.

## Attempting to detect similar passwords using zxcvbn

While checking for repeated passwords is nice and potentially useful, I thought it'd be cool if the tool could also detect passwords that are _similar_ as well, for example `Spot34` and `Spot43`. I _hoped_ that I could use that feature of zxcvbn where it optionally takes related words to accomplish this: I'd just shove all the other passwords into that Vector and see if the password still got a high-enough score.

This worked OK if the differences in the passwords where capitalization, for example `Spot34` gets a lower score if you submit `spot34` as a related word. But sadly it seems not to do anything with numbers: `Spot34` doesn't get a lower score if you submit `Spot43` along with it. 

So, for now, I've scrapped this feature. If you have any ideas on how to better implement it, let me know! 

## Paranoid mode 

As I spent more hours on this project, I wondered if any other users would trust it with their passwords. In an effect to make the program more trustworthy, I made what I call "paranoid mode". In paranoid mode, Medic can only accept user passwords if it can not connect to the internet. So user must disconnect their internet connection before using Medic. The idea here is to assure the user that the program isn't "phoning home" and/or sending their passwords somewhere without their knowledge. 

To be honest, now that I've thought about it more it's kind of security theater, but it was a weird challenge to implement. Here's some of it:


```rust
pub fn is_allowed_access_to_user_passwords(paranoid_mode: bool) -> bool {
    !(paranoid_mode && has_internet_connection())
}

pub fn has_internet_connection() -> bool {
    let urls_to_test = [
        "https://google.com".to_string(),
        "https://dropbox.com".to_string(),
        "https://github.com".to_string(),
        "https://api.pwnedpasswords.com".to_string(),
    ];

    for url in &urls_to_test {
        let response = match reqwest::get(url) {
            Ok(res) => res,
                Err(_e) => continue,
        };
        if response.status().to_string() == "200 OK" {
            return true;
        }
    }
    false
}
```

<!-- ## Creating lib.rs -->
 <!-- - https://github.com/sts10/medic/tree/91af5b975a6d0c73364c1dc1eb053f756930ed10 -->

## Learning about `is_some()` 

A small Rust thing I learned: When I implemented the keyfile functionality mentioned above, I was sure to make `keyfile_path` and Option, specifically `Option<&str>`, since not all KeePass databases are going to have key files. 

At some point I need some control flow on whether this `keyfile_path` variable was present (a `Some`) or a `None`. My Ruby instincts told me I'd be able to just write `if keyfile_path` or `if Some(keyfile_path)` and, in that context, Rust would evaluate the varaible as a Boolean. Of course Rust is much to strict to do this. But I did learn about [the `is_some()` method](https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some). 

So we have this:

```rust
if keyfile_path.is_some() {
    match Database::open(
            &mut File::open(path).unwrap(), // the database
            Some(&db_pass),                 // password
            Some(&mut File::open(std::path::Path::new(keyfile_path.unwrap())).unwrap()), // keyfile
            ) {
        Ok(db) => db,
        Err(e) => panic!("Error opening database: {}", e),
    }
} else {
    match Database::open(
            &mut File::open(path).unwrap(), // the database
            Some(&db_pass),                 // password
            None,                           // keyfile
            ) {
        Ok(db) => db,
        Err(_e) => {
            println!("\nError opening database. Maybe you have a keyfile? If so, enter its file path:");
            let keyfile_path = get_file_path().unwrap();
            unlock_keepass_database(file_path, db_pass, Some(&keyfile_path))
        }
    }
}
```

The related, more elegant solution here is Rust's [`if let`](https://doc.rust-lang.org/book/ch06-03-if-let.html), and while I've used it before, I was happy with the above code as is. Feel free to try implementing `if let` and submit a pull request though! 

## Epilogue: Collection #2 through #5

On January 31, 2019, Collections #2 through #5 dropped. [Wired reports](https://www.wired.co.uk/article/collection-data-breach-dump-leak):

> The new Collection leak, which was first reported by Heise, contains 2.2 billion unique usernames and passwords. In total it contains 845GB of data and more than 25bn records.

I'm not sure how to get my hands on this dump, but I'd be curious to see how Medic does with it. Maybe a few hours? Could be good inspiration to squeeze more efficiency out of the offline check function, and/or implement threading...
